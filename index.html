<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 Archive Streamer</title>
    <!-- jsmediatags Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <style>
        /* --- Base Theme (Same as before) --- */
        :root {
            --bg-primary: #121212; /* ... other vars */
            --list-item-hover: var(--bg-tertiary);
            --skeleton-bg: #2a2a2a;
            --skeleton-highlight: #383838;
            --player-height-desktop: 90px;
            --player-height-mobile-med: 190px; /* Increased */
            --player-height-mobile-small: 210px; /* Increased */
            --toggle-button-height: 25px;
        }

        /* --- Base Styles --- */
        body { /* ... */ padding: 0 0 var(--player-height-desktop) 0; /* Default padding */ }
        .container { /* ... */ }

        /* --- Header, Main View Toggle, Search (Mostly Same) --- */
        .header { /* ... */ }
        .header h1 { /* ... */ }
        .search-area { /* ... */ }
        .header-icon-button { /* ... */ }
        .search-container { /* ... */ }
        #search-box { /* ... */ }
        .search-icon-input { /* ... */ }
        .main-view-toggle { /* ... */ }
        .main-view-btn { /* ... */ }

        /* --- Controls Bar (Breadcrumbs / Grid-List Toggle) --- */
        .controls-bar { /* ... */ }
        .directory-container { /* ... */ }
        .directory-path { /* ... */ }
        .directory-crumb { /* ... */ }
        .directory-separator { /* ... */ }
        .view-toggle-buttons { /* ... */ }
        .view-toggle-btn { /* ... */ }

        /* --- Skeleton Loader Styles --- */
        /* ... (Same as before) ... */
        .skeleton { background-color: var(--bg-secondary); border-color: var(--border-color); pointer-events: none; position: relative; overflow: hidden; }
        .skeleton::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, var(--skeleton-highlight), transparent); animation: skeleton-shine 1.5s infinite linear; }
        @keyframes skeleton-shine { 0% { left: -100%; } 100% { left: 100%; } }
        .file-item-grid.skeleton { display: flex; flex-direction: column; align-items: center; text-align: center; padding: 15px; border-radius: 8px; border: 1px solid transparent; }
        .skeleton-icon { width: 40px; height: 40px; background-color: var(--skeleton-bg); border-radius: 4px; margin-bottom: 12px; }
        .skeleton-text { width: 80%; height: 1em; background-color: var(--skeleton-bg); border-radius: 3px; margin-bottom: 8px; }
        .skeleton-text.short { width: 50%; height: 0.8em; }
        .file-item-list.skeleton { height: 45px; display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 5px; }
        .file-browser-list .skeleton-icon { width: 20px; height: 20px; margin-bottom: 0; flex-shrink: 0; }
        .file-browser-list .skeleton-text { height: 0.9em; margin-bottom: 0; flex-grow: 1; }
        .file-browser-list .skeleton-text.short { width: 50px; flex-grow: 0; flex-shrink: 0; margin-left: auto; }

        /* --- Generic Browser Container --- */
        #file-browser-container { margin-top: 10px; }

        /* --- File Browser Grid/List Styles (Mostly Same) --- */
        /* ... (Grid styles) ... */
        .file-browser-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; }
        .file-item-grid { background-color: var(--bg-secondary); border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.2s ease-in-out; border: 1px solid var(--border-color); overflow: hidden; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .file-item-grid:hover { background-color: var(--list-item-hover); transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); }
        .file-icon-grid { font-size: 2.5rem; margin-bottom: 12px; color: var(--accent-color); line-height: 1; }
        .file-icon-grid.folder, .file-icon-grid.artist, .file-icon-grid.album { color: #77aaff; }
        .file-name-grid { font-size: 0.9rem; font-weight: 500; white-space: normal; overflow-wrap: break-word; word-break: break-all; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; margin-bottom: 5px; max-height: calc(1.3em * 3); }
        .file-info-grid { font-size: 0.75rem; color: var(--text-secondary); margin-top: auto; }
        /* ... (List Styles) ... */
         .file-browser-list { display: flex; flex-direction: column; gap: 2px; }
         .file-item-list { display: flex; align-items: center; padding: 10px 12px; background-color: var(--bg-secondary); border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease-in-out; border: 1px solid transparent; gap: 12px; }
         .file-item-list:hover { background-color: var(--list-item-hover); border-color: var(--border-color); }
         .file-item-list.non-interactive { cursor: default; opacity: 0.6; }
         .file-item-list.non-interactive:hover { background-color: var(--bg-secondary); border-color: transparent; }
         .file-icon-list { font-size: 1.2rem; color: var(--accent-color); line-height: 1; width: 20px; text-align: center; flex-shrink: 0; }
         .file-icon-list.folder, .file-icon-list.artist, .file-icon-list.album { color: #77aaff; }
         .file-name-list { font-size: 0.95rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; line-height: 1.3; }
         .file-info-list { display: flex; justify-content: flex-end; gap: 10px; min-width: 100px; text-align: right; flex-shrink: 0; }
         .file-duration-list { font-size: 0.8rem; color: var(--text-secondary); width: 45px; text-align: right; flex-shrink: 0; }
         .file-size-list { font-size: 0.8rem; color: var(--text-secondary); min-width: 55px; text-align: right; flex-shrink: 0; }
         .file-item-count { font-size: 0.8rem; color: var(--text-secondary); margin-left: auto; flex-shrink: 0; padding-left: 15px; }

        /* --- Player Section --- */
        #player-section { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 0; box-shadow: var(--player-shadow); border-top: 1px solid var(--border-color); z-index: 100; transition: height 0.3s ease, transform 0.3s ease; height: var(--player-height-desktop); overflow: hidden; }
        .player-toggle-button { position: absolute; top: calc(-1 * var(--toggle-button-height)); /* Position above */ left: 50%; transform: translateX(-50%); background-color: rgba(40, 40, 40, 0.9); border: 1px solid var(--border-color); border-bottom: none; color: var(--text-secondary); width: 50px; height: var(--toggle-button-height); border-radius: 8px 8px 0 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; z-index: 101; transition: background-color 0.2s; padding: 0; display: none; /* Hidden on desktop by default */ }
        .player-toggle-button:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .player-toggle-button .toggle-icon { transition: transform 0.3s ease; }
        .mini-progress { position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background-color: var(--progress-bar); display: none; z-index: 102; pointer-events: none; }
        .mini-progress::after { content: ''; position: absolute; left: 0; top: 0; height: 100%; background-color: var(--progress-filled); width: var(--progress-width, 0%); transition: width 0.1s linear; }
        .player-content-wrapper { display: flex; align-items: center; justify-content: space-between; width: 100%; height: 100%; gap: 15px; transition: opacity 0.3s ease; padding: 15px 20px; box-sizing: border-box; }
        .player-info { display: flex; align-items: center; gap: 15px; width: 25%; min-width: 150px; overflow: hidden; }
        .player-album-art { position: relative; width: 50px; height: 50px; background-color: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; flex-shrink: 0; color: var(--accent-color); overflow: hidden; }
        .player-album-art img { display: block; width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.3s ease; }
        .player-album-art img.loaded { opacity: 1; }
        .player-album-art #album-art-icon { position: relative; z-index: 1; transition: opacity 0.3s ease; }
        .player-album-art #album-art-icon.hidden { opacity: 0; }
        .player-album-art .loader-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 2; }
        .player-album-art .loader-overlay.visible { display: flex; }
        .player-album-art .loader-overlay .loader { margin: 0; }
        .player-text { min-width: 0; overflow: hidden; }
        .player-title { font-size: 0.95rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
        .player-subtitle { font-size: 0.8rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .player-subtitle-small { font-size: 0.7rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; opacity: 0.8; margin-top: 2px; }
        .player-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 50%; max-width: 500px; }
        .player-buttons { display: flex; align-items: center; gap: 15px; }
        .player-button { background: none; border: none; color: var(--text-primary); font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; line-height: 1; position: relative; }
        .player-button:disabled { opacity: 0.4; cursor: not-allowed; }
        .player-button:not(:disabled):hover { background-color: var(--button-bg-hover); }
        #download-btn { font-size: 1.1rem; }
        #download-btn .btn-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 18px; height: 18px; border-width: 2px; display: none; }
        #download-btn.loading .btn-icon { visibility: hidden; }
        #download-btn.loading .btn-loader { display: inline-block; }
        .play-pause-btn { background-color: var(--accent-color); width: 44px; height: 44px; }
        .play-pause-btn:not(:disabled):hover { background-color: var(--accent-hover); transform: scale(1.05); }
        .progress-container { width: 100%; display: flex; align-items: center; gap: 10px; }
        .progress-time { font-size: 0.75rem; color: var(--text-secondary); min-width: 40px; text-align: center; }
        .progress-bar-wrapper { flex-grow: 1; height: 12px; display: flex; align-items: center; cursor: pointer; padding: 4px 0; }
        .progress-bar-container { width: 100%; height: 4px; background-color: var(--progress-bar); border-radius: 2px; overflow: hidden; position: relative; }
        .progress-bar { height: 100%; background-color: var(--progress-filled); border-radius: 2px; width: 0%; position: absolute; left: 0; top: 0; transition: width 0.1s linear;}
        .progress-bar-wrapper:hover .progress-bar { background-color: var(--accent-hover); }
        .player-extras { display: flex; align-items: center; gap: 10px; width: 25%; justify-content: flex-end; min-width: 150px; flex-wrap: wrap; }
        .pitch-control, .volume-control { display: flex; align-items: center; gap: 8px; min-width: 120px; }
        .control-label { font-size: 0.8rem; color: var(--text-secondary); min-width: 35px; text-align: right; }
        .control-slider { width: 70px; height: 4px; appearance: none; background-color: var(--volume-track); border-radius: 2px; outline: none; cursor: pointer; transition: background-color 0.2s; }
        .control-slider:hover { background-color: #6a6a6a; }
        .control-slider::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; transition: transform 0.1s; }
        .control-slider:active::-webkit-slider-thumb { transform: scale(1.2); }
        .control-slider::-moz-range-thumb { width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; border: none; }
        .volume-icon { color: var(--text-secondary); font-size: 1rem; width: 20px; text-align: center; }

        /* Minimized Player State */
        #player-section.minimized { height: 35px; padding: 0; }
        #player-section.minimized .player-content-wrapper { opacity: 0; pointer-events: none; }
        #player-section.minimized .mini-progress { display: block; }
        #player-section.minimized .player-info { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 15px; background-color: rgba(30, 30, 30, 0.9); opacity: 1; pointer-events: auto; z-index: 101; }
        #player-section.minimized .player-album-art { display: none; }
        #player-section.minimized .player-text { flex-grow: 1; }
        #player-section.minimized .player-title { font-size: 0.9rem; }
        #player-section.minimized .player-subtitle, #player-section.minimized .player-subtitle-small { display: none; }
        #player-section.minimized .player-toggle-button .toggle-icon { transform: rotate(180deg); }

        /* --- Status Messages, Loader, Hint Popup (Same) --- */
        /* ... */
        .status-message { text-align: center; padding: 30px 20px; color: var(--text-secondary); font-size: 1rem; border-radius: 8px; background-color: var(--bg-secondary); margin-top: 20px; border: 1px dashed var(--border-color); display: none; }
        .status-message.visible { display: block; }
        .status-message .loader { margin-right: 10px; }
        .loader { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255, 255, 255, 0.2); border-radius: 50%; border-top-color: var(--accent-color); animation: spin 0.8s ease-in-out infinite; vertical-align: middle; }
        .btn-loader { width: 16px; height: 16px; border: 2px solid rgba(255, 255, 255, 0.3); border-top-color: var(--text-primary); }
        @keyframes spin { to { transform: rotate(360deg); } }
        #search-hint-popup { position: fixed; bottom: 20px; right: 20px; background-color: var(--hint-bg); color: var(--hint-text); padding: 10px 15px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); z-index: 101; display: none; align-items: center; gap: 10px; font-size: 0.85rem; opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease; }
        #search-hint-popup.visible { display: flex; opacity: 1; transform: translateY(0); }
        #close-hint-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.2rem; cursor: pointer; padding: 0 5px; line-height: 1; margin-left: 5px; }
        #close-hint-btn:hover { color: var(--text-primary); }


        /* --- Responsive Design --- */
        /* Desktop Base (covered above) */

        @media (max-width: 900px) { /* Medium screens / Tablets */
            .player-info, .player-extras { width: auto; flex-grow: 1; }
            .player-controls { width: auto; flex-grow: 2; max-width: 450px; } /* Slightly less max width */
            .player-extras { justify-content: center; }
            .search-area { min-width: 150px; }
            .header h1 { font-size: 1.6rem; }
        }

        @media (max-width: 768px) { /* Small tablets / Large phones */
            body { padding-bottom: calc(var(--player-height-mobile-med) + var(--toggle-button-height)); }
            .header { flex-direction: row; align-items: center; gap: 10px; }
            .header h1 { order: 1; flex-grow: 0; font-size: 1.5rem; }
            .main-view-toggle { order: 2; }
            .search-area { order: 3; flex-grow: 1; justify-content: flex-end; max-width: none; }
            .search-container.active { flex-grow: 1; max-width: none; }
            .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); }
            .file-name-list { font-size: 0.9rem; }
            .file-info-list { font-size: 0.75rem; min-width: 90px; }

            #player-section { height: var(--player-height-mobile-med); } /* Use CSS var */
            #player-section.minimized { height: 35px; }
            #player-section .player-content-wrapper {
                flex-direction: column;
                padding: 10px;
                gap: 10px; /* Gap between rows */
                justify-content: space-between; /* Push rows apart */
            }
            /* Row 1: Info */
            .player-info { justify-content: flex-start; text-align: left; width: 100%; order: 1; gap: 10px; }
            .player-album-art { width: 45px; height: 45px; }
            .player-title { font-size: 0.9rem; }
            .player-subtitle { font-size: 0.75rem; }
            .player-subtitle-small { font-size: 0.65rem; }

            /* Row 2: Progress */
            .player-controls .progress-container { order: 2; width: 100%; margin-top: 5px; }

            /* Row 3: Buttons */
            .player-controls .player-buttons { order: 3; width: 100%; justify-content: center; gap: 20px; margin-top: 8px; }
            .player-button { width: 38px; height: 38px; } /* Slightly larger touch target */
            .play-pause-btn { width: 48px; height: 48px; }

            /* Row 4: Extras */
            .player-extras {
                order: 4;
                width: 100%;
                justify-content: space-around; /* Distribute extras */
                gap: 15px; /* Gap between speed/volume */
                padding-top: 5px;
                flex-wrap: nowrap; /* Prevent wrapping within extras */
            }
            .pitch-control, .volume-control {
                flex-grow: 1; /* Allow them to take space */
                justify-content: center;
                min-width: 130px;
            }
            .control-slider { width: 100px; /* Slightly wider slider */ }

            .player-toggle-button { display: flex; } /* Show toggle */
        }

         @media (max-width: 480px) { /* Smaller phones */
             body { padding-bottom: calc(var(--player-height-mobile-small) + var(--toggle-button-height)); }
             .header { gap: 5px; padding: 10px 0; }
             .header h1 { font-size: 1.3rem; }
             .main-view-btn { font-size: 0.8rem; padding: 4px 8px;}
             .header-icon-button { width: 36px; height: 36px; font-size: 1.1rem; padding: 6px; }
             #search-box { padding-left: 35px; font-size: 0.85rem; }
             .search-icon-input { left: 12px; }
             .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
             .file-item-grid { padding: 10px; }
             .file-icon-grid { font-size: 2rem; margin-bottom: 8px; }
             .file-name-grid { font-size: 0.8rem; }
             .file-item-list { padding: 8px 10px; gap: 8px; }
             .file-icon-list { font-size: 1.1rem; width: 18px; }
             .file-name-list { font-size: 0.85rem; }
             .file-info-list { font-size: 0.7rem; min-width: 80px; gap: 5px; }
             .file-duration-list { width: 40px; }
             .file-size-list { min-width: 40px; }

             #player-section { height: var(--player-height-mobile-small); } /* Use CSS var */
             #player-section.minimized { height: 35px; }
             #player-section .player-content-wrapper { gap: 8px; padding: 8px;} /* Reduce gaps/padding */

             .player-album-art { width: 40px; height: 40px; }
             .player-title { font-size: 0.85rem; }
             .player-subtitle { font-size: 0.7rem; }
             .player-subtitle-small { font-size: 0.6rem; }

             .player-controls .player-buttons { gap: 15px; } /* Reduce button gap */
             .player-button { width: 34px; height: 34px; font-size: 1.0rem;}
             .play-pause-btn { width: 44px; height: 44px; }

             .player-extras { gap: 10px; flex-wrap: wrap; justify-content: center; } /* Allow wrapping if needed */
             .pitch-control, .volume-control { width: 100%; /* Stack if wrapped */ justify-content: center; min-width: unset; }
             .control-slider { width: 120px; } /* Wider slider when stacked */

             #search-hint-popup { bottom: 10px; right: 10px; font-size: 0.8rem; padding: 8px 12px; }
         }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header, Toggles, Search -->
        <div class="header">
            <h1>MP3 Archive</h1>
            <div class="main-view-toggle">
                <button id="folder-view-btn" class="main-view-btn" title="Browse by Folder">Folders</button>
                <button id="artist-view-btn" class="main-view-btn" title="Browse by Artist">Artists</button>
            </div>
            <div class="search-area">
                <button id="search-toggle-btn" class="header-icon-button" title="Search Files (/)">🔍</button>
                <div class="search-container" id="search-container">
                    <span class="search-icon-input">🔍</span>
                    <input type="search" id="search-box" placeholder="Search all files...">
                </div>
            </div>
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar">
            <div class="directory-container">
                <div class="directory-path" id="directory-path"></div>
            </div>
            <div class="view-toggle-buttons" id="grid-list-toggle-container">
                <button id="grid-view-btn" class="view-toggle-btn" title="Grid View">▦</button>
                <button id="list-view-btn" class="view-toggle-btn" title="List View">☰</button>
            </div>
        </div>

        <!-- Skeleton Loader -->
        <div id="skeleton-loader" class="file-browser-grid" style="display: none;">
            <!-- Placeholders -->
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        </div>

        <!-- File Browser -->
        <div id="file-browser-container"></div>

        <!-- Status Message -->
        <div id="status-message" class="status-message"></div>
    </div>

    <!-- Player Section -->
    <div id="player-section">
        <button id="player-toggle-btn" class="player-toggle-button" title="Minimize Player">
            <span class="toggle-icon">▼</span>
        </button>
        <div id="mini-progress-bar" class="mini-progress"></div>
        <div class="player-content-wrapper">
            <!-- Row 1: Info -->
            <div class="player-info">
                <div class="player-album-art" id="player-album-art">
                    <img id="album-art-img" src="" alt="Album Art" />
                    <span id="album-art-icon">🎵</span>
                    <div class="loader-overlay"><span class="loader"></span></div>
                </div>
                <div class="player-text">
                    <div id="now-playing" class="player-title" title="Not playing">Not playing</div>
                    <div id="now-playing-artist-album" class="player-subtitle" title="Select an MP3 file">Select an MP3 file</div>
                    <div id="now-playing-path" class="player-subtitle-small"></div>
                </div>
            </div>
            <!-- Rows 2 & 3: Controls (includes progress and buttons) -->
            <div class="player-controls">
                 <div class="progress-container">
                    <span id="current-time" class="progress-time">0:00</span>
                    <div class="progress-bar-wrapper" id="progress-wrapper">
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progress-bar"></div>
                        </div>
                    </div>
                    <span id="duration" class="progress-time">0:00</span>
                </div>
                 <div class="player-buttons">
                    <button class="player-button" id="prev-btn" disabled title="Previous Track (←)">⏮</button>
                    <button id="play-pause-btn" class="player-button play-pause-btn" disabled title="Play/Pause (Space)">▶</button>
                    <button class="player-button" id="next-btn" disabled title="Next Track (→)">⏭</button>
                    <button class="player-button" id="download-btn" title="Download current track" disabled>
                        <span class="btn-icon">💾</span>
                        <span class="loader btn-loader"></span>
                    </button>
                </div>
            </div>
             <!-- Row 4: Extras -->
            <div class="player-extras">
                 <div class="pitch-control">
                    <span class="control-label">Speed</span>
                    <input type="range" class="control-slider pitch-slider" id="pitch-slider" min="0.5" max="2" step="0.05" value="1" disabled>
                </div>
                <div class="volume-control">
                    <span class="volume-icon" id="volume-icon">🔊</span>
                    <input type="range" class="control-slider volume-slider" id="volume-slider" min="0" max="1" step="0.05" value="0.7">
                </div>
            </div>
        </div><!-- End player-content-wrapper -->
    </div>

    <!-- Main Audio Element -->
    <audio id="audio-player" preload="metadata" style="display: none;"></audio>

    <!-- Search Hint Popup -->
    <div id="search-hint-popup">
         <span>Tip: Tap 🔍 or press <kbd>/</kbd> to search</span>
         <button id="close-hint-btn" title="Dismiss hint">✕</button>
    </div>

    <script>
        // --- Configuration ---
        const archiveIdentifier = 'silent_hill_2_ost'; // <<< CHANGE THIS
        const archiveApiUrl = `https://archive.org/metadata/${archiveIdentifier}`;
        const archiveDownloadUrlBase = `https://archive.org/download/${archiveIdentifier}`;
        const excludedExtensions = ['.xml', '.txt', '.torrent', '.jpg', '.png', '.gif', '.log', '.php', '.html', '.css', '.js', '.pdf', '.zip', '.rar', '.jpeg', '.md5', '.json', '_meta.sqlite', '_files.xml'];
        // const FETCH_TIMEOUT_MS = 25000; // Timeout less critical for <audio> tag src
        // const MAX_RETRIES = 2; // Retry less critical for <audio> tag src
        const MAX_CACHE_SIZE = 20; // Cache for metadata/art fetching
        const SEEK_TIME_SECONDS = 5;
        const UNKNOWN_ARTIST = "[Unknown Artist]";
        const UNKNOWN_ALBUM = "[Unknown Album]";
        const TAG_FETCH_RANGE = 'bytes=0-131071'; // Fetch ~128KB for tags initially

        // --- DOM Elements ---
        const audioElement = document.getElementById('audio-player'); // The MAIN audio element
        // ... (all other DOM element variables, same as before)
        const searchToggleBtn = document.getElementById('search-toggle-btn');
        const searchContainer = document.getElementById('search-container');
        const searchBox = document.getElementById('search-box');
        const directoryPathEl = document.getElementById('directory-path');
        const fileBrowserContainerEl = document.getElementById('file-browser-container');
        const skeletonLoaderEl = document.getElementById('skeleton-loader');
        const statusMessageEl = document.getElementById('status-message');
        const playerSection = document.getElementById('player-section');
        const playerToggleBtn = document.getElementById('player-toggle-btn');
        const playerContentWrapper = document.querySelector('.player-content-wrapper');
        const miniProgressBar = document.getElementById('mini-progress-bar');
        const playerAlbumArt = document.getElementById('player-album-art');
        const albumArtImg = document.getElementById('album-art-img');
        const albumArtIcon = document.getElementById('album-art-icon');
        const albumArtLoader = playerAlbumArt.querySelector('.loader-overlay');
        const nowPlayingEl = document.getElementById('now-playing');
        const nowPlayingArtistAlbumEl = document.getElementById('now-playing-artist-album');
        const nowPlayingPathEl = document.getElementById('now-playing-path');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const downloadBtn = document.getElementById('download-btn');
        const progressWrapper = document.getElementById('progress-wrapper');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeIcon = document.getElementById('volume-icon');
        const pitchSlider = document.getElementById('pitch-slider');
        const searchHintPopup = document.getElementById('search-hint-popup');
        const closeHintBtn = document.getElementById('close-hint-btn');
        const gridViewBtn = document.getElementById('grid-view-btn');
        const listViewBtn = document.getElementById('list-view-btn');
        const gridListToggleContainer = document.getElementById('grid-list-toggle-container');
        const folderViewBtn = document.getElementById('folder-view-btn');
        const artistViewBtn = document.getElementById('artist-view-btn');

        // --- Audio State ---
        // let audioContext; // Keep for volume/potential effects
        // let gainNode;
        // let sourceNode; // No longer using BufferSource for playback
        // let currentAudioBuffer; // No longer caching decoded buffer
        let isPlaying = false; // Track player state based on <audio> events
        let currentPlaybackRate = 1.0;
        let currentVolume = 0.7;
        let progressUpdateInterval; // Still useful potentially, or rely only on timeupdate?
        // let fetchAbortController = null; // Less critical now

        // --- Data State ---
        let currentDirectory = '';
        let currentArtist = null;
        let currentAlbum = null;
        let allArchiveFiles = []; // Master list of ALL files/folders
        let artistsData = {};
        let isArtistsDataBuilt = false;
        let currentDirectoryItems = []; // Items currently shown in browser
        let currentTracklist = []; // Playable tracks in the current VIEW
        let currentTrackIndex = -1;
        let currentPlayingFile = null; // Holds the full file object being played
        let currentLayoutMode = localStorage.getItem('layoutMode') || 'grid';
        let currentMainView = localStorage.getItem('mainView') || 'folder';
        let isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true';

        // --- Caching (Now primarily for fetched metadata/art) ---
        const metadataCache = new Map(); // Cache fetched jsmediatags results <filePath, metadata>
        const cacheOrder = []; // LRU for metadata cache

        // --- Constants ---
        const VIEW_MODE_FOLDER = 'folder';
        const VIEW_MODE_ARTIST = 'artist';

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            // setupAudioContext(); // Init context if needed for volume/effects
            loadArchiveStructure();
            setupEventListeners(); // Includes audio element listeners now
            updatePlayerUI();
            applyLayoutMode();
            applyMainViewMode();
            applyMinimizedState();
            updateBodyPadding(); // Adjust body padding based on player state
            showSearchHintIfNeeded();
        });

        function loadSettings() { /* ... same ... */ currentVolume = parseFloat(localStorage.getItem('playerVolume') || '0.7'); currentPlaybackRate = parseFloat(localStorage.getItem('playerRate') || '1.0'); isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true'; currentLayoutMode = localStorage.getItem('layoutMode') || 'grid'; currentMainView = localStorage.getItem('mainView') || 'folder'; audioElement.volume = currentVolume; audioElement.playbackRate = currentPlaybackRate; volumeSlider.value = currentVolume; pitchSlider.value = currentPlaybackRate; updateVolumeIcon(currentVolume); }
        function saveSetting(key, value) { /* ... same ... */ try { localStorage.setItem(key, value); } catch (e) { console.warn(`Could not save setting ${key}:`, e); } }
        // function setupAudioContext() { /* Keep if using GainNode */ /* ... */ }


        // --- Archive.org API & Data Handling ---
        async function loadArchiveStructure() { /* ... same logic ... */ showInitialLoading(); try { const response = await fetch(archiveApiUrl); if (!response.ok) throw new Error(`Metadata fetch failed (Status: ${response.status})`); const data = await response.json(); if (!data.files || !Array.isArray(data.files)) throw new Error('Invalid archive structure: No files array found.'); allArchiveFiles = processRawFiles(data.files); console.log(`Processed ${allArchiveFiles.length} total items from archive.`); const totalAudioFiles = allArchiveFiles.filter(f => f.isAudio).length; console.log(`Found ${totalAudioFiles} audio files in total.`); buildArtistViewData(allArchiveFiles); if (currentMainView === VIEW_MODE_ARTIST) { renderArtistList(); } else { updateDirectoryView(''); } updateMainViewToggleButtons(); hideInitialLoading(); } catch (error) { console.error('Error loading archive:', error); displayStatus(`Error loading archive: ${error.message}`, true); hideInitialLoading(); } }
        function processRawFiles(rawFiles) { /* ** CRITICAL - Ensure isDirectory is robust ** */ const fileMap = new Map(); rawFiles.forEach(file => fileMap.set(file.name, file)); return rawFiles.map(file => { const path = file.name; let displayName = path.split('/').filter(p => p).pop() || path; let isDirectory = path.endsWith('/'); /* ** More Robust Directory Check ** */ if (!isDirectory) { for (const otherPath of fileMap.keys()) { if (otherPath !== path && otherPath.startsWith(path + '/')) { isDirectory = true; break; } } } let durationSeconds = undefined; if (file.length && !isNaN(parseFloat(file.length))) { durationSeconds = parseFloat(file.length); } let apiArtist = file.creator || file.artist || null; let apiAlbum = file.album || null; let apiTitle = file.title || null; if (apiArtist && typeof apiArtist === 'string') apiArtist = apiArtist.split(';')[0].trim(); if (apiAlbum && typeof apiAlbum === 'string') apiAlbum = apiAlbum.split(';')[0].trim(); return { name: file.name, path: path, size: file.size ? parseInt(file.size) : 0, format: file.format || '', isDirectory: isDirectory, isAudio: !isDirectory && path.toLowerCase().endsWith('.mp3'), displayName: displayName, duration: durationSeconds, artist: apiArtist, album: apiAlbum, title: apiTitle, metadata: null }; }).filter(file => { if (file.isDirectory) return true; if (file.isAudio) { const extension = file.path.substring(file.path.lastIndexOf('.')).toLowerCase(); return !excludedExtensions.includes(extension); } return false; }).sort((a, b) => { if (a.isDirectory && !b.isDirectory) return -1; if (!a.isDirectory && b.isDirectory) return 1; return (a.displayName || '').localeCompare(b.displayName || ''); }); }
        function buildArtistViewData(files) { /* ... same logic using isAudio filter ... */ console.log(`Building artist view data from ${files.length} received items...`); const tempArtistsData = {}; let audioFileCount = 0; files.forEach(file => { if (!file.isAudio) return; audioFileCount++; const artist = file.artist || UNKNOWN_ARTIST; const album = file.album || UNKNOWN_ALBUM; if (!tempArtistsData[artist]) tempArtistsData[artist] = { _albums: {} }; if (!tempArtistsData[artist]._albums[album]) tempArtistsData[artist]._albums[album] = []; tempArtistsData[artist]._albums[album].push(file); }); Object.keys(tempArtistsData).forEach(artist => { Object.keys(tempArtistsData[artist]._albums).forEach(album => { tempArtistsData[artist]._albums[album].sort((a, b) => (a.title || a.displayName).localeCompare(b.title || b.displayName)); }); }); artistsData = Object.fromEntries(Object.entries(tempArtistsData).sort(([artistA], [artistB]) => artistA.localeCompare(artistB))); isArtistsDataBuilt = true; console.log(`Artist view data built. Artists: ${Object.keys(artistsData).length}, Audio Files processed: ${audioFileCount}`); if (currentMainView === VIEW_MODE_ARTIST && !currentArtist && !currentAlbum) { renderArtistList(); } }

        // --- Skeleton Loader & Status ---
        /* ... (Same skeleton functions as before) ... */
        function showInitialLoading() { showSkeletonLoader(true); statusMessageEl.innerHTML = `<span class="loader"></span>Loading archive...`; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; }
        function hideInitialLoading() { hideSkeletonLoader(); if (statusMessageEl.textContent.includes("Loading archive")) { statusMessageEl.classList.remove('visible'); statusMessageEl.innerHTML = ''; } }
        function showSkeletonLoader(show) { skeletonLoaderEl.style.display = show ? (currentLayoutMode === 'grid' ? 'grid' : 'flex') : 'none'; /* Apply flex for list skeleton */ skeletonLoaderEl.className = `file-browser-${currentLayoutMode} visible`; }
        function hideSkeletonLoader() { skeletonLoaderEl.style.display = 'none'; }
        function displayStatus(message, isError = false) { statusMessageEl.innerHTML = message; statusMessageEl.style.color = isError ? 'var(--accent-color)' : 'var(--text-secondary)'; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; hideSkeletonLoader(); }
        function hideLoading() { if (!statusMessageEl.style.color.includes('accent')) { statusMessageEl.classList.remove('visible'); } }

        // --- View Mode Switching (Main & Layout) ---
        /* ... (Same setMainViewMode, applyMainViewMode, updateMainViewToggleButtons, setLayoutMode, applyLayoutMode as before) ... */
        function setMainViewMode(mode) { if (mode === currentMainView) return; currentMainView = mode; saveSetting('mainView', mode); applyMainViewMode(); currentArtist = null; currentAlbum = null; searchBox.value = ''; if(searchContainer.classList.contains('active')) toggleSearch(false); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; requestAnimationFrame(() => { if (mode === VIEW_MODE_ARTIST) { if (!isArtistsDataBuilt) { displayStatus("Building artist data..."); } else { renderArtistList(); } } else { updateDirectoryView(currentDirectory); } }); }
        function applyMainViewMode() { updateMainViewToggleButtons(); updateBreadcrumbs(); const showGridListToggle = (currentMainView === VIEW_MODE_FOLDER) || (currentMainView === VIEW_MODE_ARTIST && currentArtist && currentAlbum); gridListToggleContainer.style.display = showGridListToggle ? 'flex' : 'none'; }
        function updateMainViewToggleButtons() { folderViewBtn.classList.toggle('active', currentMainView === VIEW_MODE_FOLDER); artistViewBtn.classList.toggle('active', currentMainView === VIEW_MODE_ARTIST); }
        function setLayoutMode(mode) { if (mode === currentLayoutMode) return; currentLayoutMode = mode; saveSetting('layoutMode', mode); applyLayoutMode(); rerenderCurrentView(); }
        function applyLayoutMode() { gridViewBtn.classList.toggle('active', currentLayoutMode === 'grid'); listViewBtn.classList.toggle('active', currentLayoutMode === 'list'); skeletonLoaderEl.className = `file-browser-${currentLayoutMode} visible`; }


        // --- Re-rendering Logic ---
        function rerenderCurrentView() { /* ... same ... */ showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; requestAnimationFrame(() => { if (searchBox.value) { handleSearch(); } else if (currentMainView === VIEW_MODE_ARTIST) { if (currentArtist && currentAlbum) renderTrackListForArtist(currentArtist, currentAlbum); else if (currentArtist) renderAlbumList(currentArtist); else renderArtistList(); } else { updateDirectoryView(currentDirectory); } }); }


        // --- Rendering Functions (Folder View) ---
        function updateDirectoryView(path) { /* ... same ... */ if (currentMainView !== VIEW_MODE_FOLDER) { console.warn("updateDirectoryView called while not in folder view"); return; } showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentDirectory = path; currentArtist = null; currentAlbum = null; if (searchBox.value) { searchBox.value = ''; toggleSearch(false);} updateBreadcrumbs(); const items = getItemsInDirectory(allArchiveFiles, path); currentDirectoryItems = items; currentTracklist = items.filter(item => item.isAudio); currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; requestAnimationFrame(() => { renderFileBrowser(items); hideSkeletonLoader(); updatePrevNextButtons(); if (items.length === 0) displayStatus("This directory is empty.", false); else hideLoading(); }); }
        function getItemsInDirectory(allItems, dirPath) { /* Uses the CORRECTED logic from previous response */ const items = new Map(); const dirPathLength = dirPath.length; allItems.forEach(item => { if (!item.path.startsWith(dirPath) || item.path === dirPath) return; const relativePath = item.path.substring(dirPathLength); const slashIndex = relativePath.indexOf('/'); if (slashIndex === -1) { if (!item.isDirectory) { items.set(item.path, item); } } else { const firstPart = relativePath.substring(0, slashIndex); const subDirPath = dirPath + firstPart + '/'; if (!items.has(subDirPath)) { let dirEntry = allItems.find(d => d.path === subDirPath && d.isDirectory); if (dirEntry) { items.set(subDirPath, dirEntry); } else { items.set(subDirPath, { name: subDirPath, path: subDirPath, displayName: firstPart, isDirectory: true, isAudio: false, size: 0, format: 'Directory (Synthesized)' }); } } if (item.isDirectory && item.path.endsWith('/') && slashIndex === (relativePath.length - 1)) { if (!items.has(item.path)) { items.set(item.path, item); } } } }); return Array.from(items.values()).sort((a, b) => { if (a.isDirectory && !b.isDirectory) return -1; if (!a.isDirectory && b.isDirectory) return 1; const nameA = a.displayName || ''; const nameB = b.displayName || ''; return nameA.localeCompare(nameB); }); }

        // --- Rendering Functions (Artist View) ---
        function renderArtistList() { /* ... same ... */ if (currentMainView !== VIEW_MODE_ARTIST) return; showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = null; currentAlbum = null; updateBreadcrumbs(); if (!isArtistsDataBuilt) { displayStatus("Building artist data..."); return; } if (Object.keys(artistsData).length === 0) { displayStatus("No artist information found.", false); hideSkeletonLoader(); return; } const itemsToRender = Object.keys(artistsData).map(artistName => ({ name: artistName, isArtist: true, itemCount: Object.keys(artistsData[artistName]._albums).length })); currentDirectoryItems = itemsToRender; currentTracklist = []; currentTrackIndex = -1; updatePrevNextButtons(); requestAnimationFrame(() => { renderArtistAlbumBrowser(itemsToRender); hideSkeletonLoader(); hideLoading(); }); }
        function renderAlbumList(artistName) { /* ... same ... */ if (currentMainView !== VIEW_MODE_ARTIST || !artistsData[artistName]) return; showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = artistName; currentAlbum = null; updateBreadcrumbs(); const albums = artistsData[artistName]._albums; if (Object.keys(albums).length === 0) { displayStatus(`No albums found for ${artistName}.`, false); hideSkeletonLoader(); return; } const itemsToRender = Object.keys(albums).map(albumName => ({ name: albumName, isAlbum: true, itemCount: albums[albumName].length })); currentDirectoryItems = itemsToRender; currentTracklist = []; currentTrackIndex = -1; updatePrevNextButtons(); requestAnimationFrame(() => { renderArtistAlbumBrowser(itemsToRender); hideSkeletonLoader(); hideLoading(); }); }
        function renderTrackListForArtist(artistName, albumName) { /* ... same ... */ if (currentMainView !== VIEW_MODE_ARTIST || !artistsData[artistName]?._albums[albumName]) return; showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = artistName; currentAlbum = albumName; updateBreadcrumbs(); const tracks = artistsData[artistName]._albums[albumName]; if (tracks.length === 0) { displayStatus(`No tracks found for ${albumName}.`, false); hideSkeletonLoader(); return; } currentDirectoryItems = tracks; currentTracklist = tracks; currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; updatePrevNextButtons(); requestAnimationFrame(() => { renderFileBrowser(tracks); hideSkeletonLoader(); hideLoading(); }); }


        // --- Combined Rendering Dispatchers ---
        function renderFileBrowser(items) { /* Renders Folders & Files */ /* ... same ... */ fileBrowserContainerEl.innerHTML = ''; fileBrowserContainerEl.className = ''; if (currentLayoutMode === 'list') { fileBrowserContainerEl.classList.add('file-browser-list'); renderFileBrowserList(items); } else { fileBrowserContainerEl.classList.add('file-browser-grid'); renderFileBrowserGrid(items); } }
        function renderArtistAlbumBrowser(items) { /* Renders Artists or Albums */ /* ... same ... */ fileBrowserContainerEl.innerHTML = ''; fileBrowserContainerEl.className = ''; if (currentLayoutMode === 'list') { fileBrowserContainerEl.classList.add('file-browser-list'); renderArtistAlbumList(items); } else { fileBrowserContainerEl.classList.add('file-browser-grid'); renderArtistAlbumGrid(items); } }

        // --- Grid/List Rendering Implementations ---
        /* ... (Same renderFileBrowserGrid, renderArtistAlbumGrid, renderFileBrowserList, renderArtistAlbumList as before) ... */
        function renderFileBrowserGrid(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-grid'; itemEl.dataset.path = item.path; const icon = document.createElement('div'); icon.className = 'file-icon-grid'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-grid'; nameEl.textContent = item.displayName || '[No Name]'; nameEl.title = item.displayName || item.path; const infoEl = document.createElement('div'); infoEl.className = 'file-info-grid'; if (item.isDirectory) { icon.textContent = '📁'; icon.classList.add('folder'); itemEl.addEventListener('click', () => updateDirectoryView(item.path)); infoEl.textContent = 'Folder'; } else if (item.isAudio) { icon.textContent = '🎵'; itemEl.addEventListener('click', () => playAudioFile(item, currentTracklist)); infoEl.textContent = formatFileSize(item.size); } itemEl.appendChild(icon); itemEl.appendChild(nameEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderArtistAlbumGrid(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-grid'; itemEl.dataset.name = item.name; const icon = document.createElement('div'); icon.className = 'file-icon-grid'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-grid'; nameEl.textContent = item.name; nameEl.title = item.name; const infoEl = document.createElement('div'); infoEl.className = 'file-info-grid'; if (item.isArtist) { icon.textContent = '👤'; icon.classList.add('artist'); itemEl.addEventListener('click', () => renderAlbumList(item.name)); infoEl.textContent = `${item.itemCount} Album${item.itemCount !== 1 ? 's' : ''}`; } else if (item.isAlbum) { icon.textContent = '💿'; icon.classList.add('album'); itemEl.addEventListener('click', () => renderTrackListForArtist(currentArtist, item.name)); infoEl.textContent = `${item.itemCount} Track${item.itemCount !== 1 ? 's' : ''}`; } itemEl.appendChild(icon); itemEl.appendChild(nameEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderFileBrowserList(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = `file-item-list ${item.isAudio || item.isDirectory ? '' : 'non-interactive'}`; itemEl.dataset.path = item.path; const icon = document.createElement('div'); icon.className = 'file-icon-list'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-list'; nameEl.textContent = item.title || item.displayName || '[No Name]'; nameEl.title = item.displayName || item.path; const infoEl = document.createElement('div'); infoEl.className = 'file-info-list'; const durationEl = document.createElement('span'); durationEl.className = 'file-duration-list'; const sizeEl = document.createElement('span'); sizeEl.className = 'file-size-list'; if (item.isDirectory) { icon.textContent = '📁'; icon.classList.add('folder'); itemEl.addEventListener('click', () => updateDirectoryView(item.path)); sizeEl.textContent = 'Folder'; } else if (item.isAudio) { icon.textContent = '🎵'; itemEl.addEventListener('click', () => playAudioFile(item, currentTracklist)); durationEl.textContent = item.duration ? formatTime(item.duration) : '--:--'; durationEl.dataset.path = item.path; sizeEl.textContent = formatFileSize(item.size); } else { icon.textContent = '📄'; sizeEl.textContent = formatFileSize(item.size); } itemEl.appendChild(icon); itemEl.appendChild(nameEl); infoEl.appendChild(durationEl); infoEl.appendChild(sizeEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderArtistAlbumList(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-list'; itemEl.dataset.name = item.name; const icon = document.createElement('div'); icon.className = 'file-icon-list'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-list'; nameEl.textContent = item.name; nameEl.title = item.name; const infoEl = document.createElement('div'); infoEl.className = 'file-info-list'; const countEl = document.createElement('span'); countEl.className = 'file-item-count'; if (item.isArtist) { icon.textContent = '👤'; icon.classList.add('artist'); itemEl.addEventListener('click', () => renderAlbumList(item.name)); countEl.textContent = `${item.itemCount} Album${item.itemCount !== 1 ? 's' : ''}`; } else if (item.isAlbum) { icon.textContent = '💿'; icon.classList.add('album'); itemEl.addEventListener('click', () => renderTrackListForArtist(currentArtist, item.name)); countEl.textContent = `${item.itemCount} Track${item.itemCount !== 1 ? 's' : ''}`; } itemEl.appendChild(icon); itemEl.appendChild(nameEl); infoEl.appendChild(countEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }


        function formatFileSize(bytes) { /* ... same ... */ if (bytes === undefined || bytes === null || bytes < 0) return ''; if (bytes === 0) return '0 B'; if (bytes < 1024) return bytes + ' B'; const i = Math.floor(Math.log(bytes) / Math.log(1024)); const units = ['B', 'KB', 'MB', 'GB', 'TB']; const unitIndex = Math.min(i, units.length - 1); const fixedDigits = unitIndex >= 2 ? 1 : 0; return parseFloat((bytes / Math.pow(1024, unitIndex)).toFixed(fixedDigits)) + ' ' + units[unitIndex];}

        // --- Breadcrumbs ---
        function updateBreadcrumbs() { /* ... same logic ... */ directoryPathEl.innerHTML = ''; if (currentMainView === VIEW_MODE_ARTIST) { const artistsCrumb = createArtistCrumb('Artists', null, null, !currentArtist && !currentAlbum); directoryPathEl.appendChild(artistsCrumb); if (currentArtist) { addSeparator(); const artistCrumb = createArtistCrumb(currentArtist, currentArtist, null, !currentAlbum); directoryPathEl.appendChild(artistCrumb); } if (currentAlbum) { addSeparator(); const albumCrumb = createArtistCrumb(currentAlbum, currentArtist, currentAlbum, true); directoryPathEl.appendChild(albumCrumb); } } else { const rootCrumb = createFolderCrumb('Root', '', currentDirectory === ''); directoryPathEl.appendChild(rootCrumb); const parts = currentDirectory.split('/').filter(part => part !== ''); let pathAccumulator = ''; parts.forEach((part) => { pathAccumulator += part + '/'; addSeparator(); const crumb = createFolderCrumb(part, pathAccumulator, pathAccumulator === currentDirectory); directoryPathEl.appendChild(crumb); }); } }
        function addSeparator() { const separator = document.createElement('span'); separator.className = 'directory-separator'; separator.textContent = '›'; directoryPathEl.appendChild(separator); }
        function createFolderCrumb(text, path, isCurrent) { /* ... same ... */ const crumb = document.createElement('span'); crumb.className = `directory-crumb ${isCurrent ? 'current' : ''}`; crumb.textContent = text; if (!isCurrent) { crumb.addEventListener('click', () => updateDirectoryView(path)); } return crumb; }
        function createArtistCrumb(text, artist, album, isCurrent) { /* ... same ... */ const crumb = document.createElement('span'); crumb.className = `directory-crumb ${isCurrent ? 'current' : ''}`; crumb.textContent = text; if (!isCurrent) { crumb.addEventListener('click', () => { if (artist && album) { renderAlbumList(artist); } else if (artist) { renderArtistList(); } else { renderArtistList(); } }); } return crumb; }


        // --- Search Functionality ---
        function toggleSearch(forceState) { /* ... same ... */ const activate = forceState !== undefined ? forceState : !searchContainer.classList.contains('active'); if (activate) { searchContainer.classList.add('active'); searchBox.focus(); } else { searchContainer.classList.remove('active'); searchBox.blur(); } }
        function handleSearch() { /* ... same logic, searches flat files ... */ showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; const searchTerm = searchBox.value.toLowerCase().trim(); if (!searchTerm) { applyMainViewMode(); rerenderCurrentView(); return; } const results = allArchiveFiles.filter(file => !file.isDirectory && file.isAudio && (file.path.toLowerCase().includes(searchTerm) || (file.title && file.title.toLowerCase().includes(searchTerm)) || (file.artist && file.artist.toLowerCase().includes(searchTerm)) || (file.album && file.album.toLowerCase().includes(searchTerm))) ).sort((a, b) => (a.title || a.displayName).localeCompare(b.title || b.displayName)); currentDirectoryItems = results; currentTracklist = results; currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; updatePrevNextButtons(); directoryPathEl.innerHTML = ''; const searchCrumb = createFolderCrumb(`Search: "${searchTerm}"`, '', true); directoryPathEl.appendChild(searchCrumb); gridListToggleContainer.style.display = 'flex'; requestAnimationFrame(() => { renderFileBrowser(results); hideSkeletonLoader(); if (results.length === 0) displayStatus(`No results found for "${searchTerm}".`, false); else hideLoading(); }); }

        // --- Metadata Handling ---
        async function fetchTagsWithRange(url) {
             // Fetch only the beginning of the file for tags
             try {
                 const response = await fetch(url, { headers: { 'Range': TAG_FETCH_RANGE } });
                 if (!response.ok || !(response.status === 200 || response.status === 206)) { // 206 Partial Content is OK
                     throw new Error(`Tag fetch failed: ${response.status}`);
                 }
                 const arrayBuffer = await response.arrayBuffer();
                 return arrayBuffer;
             } catch (error) {
                 console.warn(`Could not fetch initial bytes for tags (${url}):`, error);
                 return null; // Indicate failure
             }
         }
        async function getMetadataFromTags(file) {
            // Check cache first
             if (metadataCache.has(file.path)) {
                 return metadataCache.get(file.path);
             }
             // Fetch limited range for tags
             const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`;
             const tagData = await fetchTagsWithRange(fileUrl);
             if (!tagData) return {}; // Failed to fetch tag data

            return new Promise((resolve) => {
                 if (typeof jsmediatags === 'undefined') { resolve({}); return; }
                 jsmediatags.read(tagData, { // Pass ArrayBuffer directly
                    onSuccess: (tag) => {
                         const metadata = { title: tag.tags.title, artist: tag.tags.artist, album: tag.tags.album, picture: tag.tags.picture };
                         manageMetadataCache(file.path, metadata); // Cache result
                         resolve(metadata);
                     },
                    onError: (error) => { console.warn('jsmediatags error:', file?.path, error.type); resolve({}); } // Resolve empty on error
                });
            });
        }
        function displayMetadataInPlayer(metadata) { /* ... same logic ... */ const title = metadata?.title || currentPlayingFile?.title || currentPlayingFile?.displayName || 'Unknown Title'; const artist = metadata?.artist || currentPlayingFile?.artist || UNKNOWN_ARTIST; const album = metadata?.album || currentPlayingFile?.album || UNKNOWN_ALBUM; nowPlayingEl.textContent = title; nowPlayingEl.title = title; let artistAlbumText = artist === UNKNOWN_ARTIST ? album : (album === UNKNOWN_ALBUM ? artist : `${artist} • ${album}`); if (artist === UNKNOWN_ARTIST && album === UNKNOWN_ALBUM) { artistAlbumText = 'Unknown Artist / Album'; } nowPlayingArtistAlbumEl.textContent = artistAlbumText; nowPlayingArtistAlbumEl.title = artistAlbumText; const pathParts = currentPlayingFile?.path?.split('/').filter(p => p); pathParts?.pop(); nowPlayingPathEl.textContent = pathParts?.length > 0 ? pathParts.join('/') : ''; nowPlayingPathEl.title = currentPlayingFile?.path || ''; albumArtLoader.classList.remove('visible'); albumArtIcon.classList.remove('hidden'); albumArtImg.classList.remove('loaded'); albumArtImg.src = ''; if (metadata?.picture) { try { const { data, format } = metadata.picture; let base64String = ""; for (let i = 0; i < data.length; i++) base64String += String.fromCharCode(data[i]); const imageUrl = `data:${format};base64,${window.btoa(base64String)}`; albumArtImg.onload = () => albumArtImg.classList.add('loaded'); albumArtImg.onerror = () => albumArtIcon.classList.remove('hidden'); albumArtImg.src = imageUrl; albumArtIcon.classList.add('hidden'); } catch (e) { console.error("Error displaying album art:", e); albumArtIcon.classList.remove('hidden'); } } }

        // --- Caching Logic (Metadata) ---
        function manageMetadataCache(filePath, data) { /* Updated for metadata */ if (metadataCache.size >= MAX_CACHE_SIZE) { const oldestPath = cacheOrder.shift(); if (oldestPath) { metadataCache.delete(oldestPath); } } metadataCache.set(filePath, data); cacheOrder.push(filePath); }
        function clearMetadataCache() { metadataCache.clear(); cacheOrder.length = 0; console.log("Metadata cache cleared."); }


        // --- Audio Playback (Using <audio> Element) ---
         function playAudioFile(file, contextTracklist) {
            if (!file || !file.isAudio) return;

            console.log("Requesting playback:", file.path);
            stopPlayback(); // Stop previous playback

            currentPlayingFile = file;
            currentTracklist = contextTracklist || [];
            currentTrackIndex = currentTracklist.findIndex(track => track.path === file.path);

             // Update UI immediately (basic info)
            updatePlayerUI(true, 'Loading...'); // Show loading state
            displayMetadataInPlayer({ title: file.title || file.displayName, artist: file.artist, album: file.album }); // Show API/initial metadata

            const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`;
            audioElement.src = fileUrl;
            audioElement.load(); // Start loading the source

            // Attempt to play immediately - browser will start when ready
            audioElement.play().catch(error => {
                 // Autoplay might be blocked by browser policy initially
                 console.warn("Playback initiation failed (likely autoplay policy):", error.message);
                 // UI should reflect paused state until user interaction
                 updatePlayerUI();
                 playPauseBtn.textContent = '▶'; // Ensure play button shows
            });

             // Fetch richer tags in the background
             getMetadataFromTags(file).then(tagsMetadata => {
                 if (currentPlayingFile && currentPlayingFile.path === file.path) { // Check if still playing the same file
                     // Refine metadata in the player display
                      currentPlayingFile.metadata = tagsMetadata; // Store fetched tags
                      currentPlayingFile.title = tagsMetadata?.title || currentPlayingFile.title;
                      currentPlayingFile.artist = tagsMetadata?.artist || currentPlayingFile.artist;
                      currentPlayingFile.album = tagsMetadata?.album || currentPlayingFile.album;
                      displayMetadataInPlayer(tagsMetadata); // Update player with richer info
                 }
             });
        }

         function stopPlayback(clearInfo = false) {
             console.log("Stopping playback. Clear info:", clearInfo);
             audioElement.pause();
             audioElement.removeAttribute('src'); // Remove source to stop loading/decoding
             audioElement.load(); // Reset element state
             isPlaying = false;
             // clearInterval(progressUpdateInterval); // Use timeupdate listener instead

             if (clearInfo) {
                 currentPlayingFile = null;
                 // currentAudioBuffer = null; // Not used anymore
                 currentTrackIndex = -1;
                 updatePlayerUI();
                 updatePrevNextButtons();
             } else {
                  // Keep currentPlayingFile, update UI to paused state
                 updatePlayerUI(); // Update button state
                 // Progress bar might reset slightly due to removing src, updateProgress handles this
                 updateProgress();
             }
        }

         function togglePlayback() {
             if (!currentPlayingFile) return; // Nothing to play/pause

             if (audioElement.paused) {
                 audioElement.play().catch(e => console.error("Play failed:", e));
             } else {
                 audioElement.pause();
             }
             // State/UI update handled by 'play' and 'pause' event listeners
         }

         function seek(offsetSeconds) {
             if (!currentPlayingFile || isNaN(audioElement.duration)) return;
             const currentTime = audioElement.currentTime;
             let seekTime = currentTime + offsetSeconds;
             // Clamp within bounds (0 to duration)
             seekTime = Math.max(0, Math.min(seekTime, audioElement.duration));
             console.log(`Seeking by ${offsetSeconds}s to: ${formatTime(seekTime)}`);
             audioElement.currentTime = seekTime;
             updateProgress(); // Update UI immediately
         }

         function playNext() { /* ... same logic, calls playAudioFile ... */ if (currentTracklist.length === 0 || currentTrackIndex === -1) return; let nextIndex = currentTrackIndex + 1; if (nextIndex >= currentTracklist.length) nextIndex = 0; if (currentTracklist[nextIndex]) playAudioFile(currentTracklist[nextIndex], currentTracklist); else stopPlayback(true); }
         function playPrev() { /* ... same logic, calls playAudioFile ... */ if (currentTracklist.length === 0 || currentTrackIndex === -1) return; let prevIndex = currentTrackIndex - 1; if (prevIndex < 0) prevIndex = currentTracklist.length - 1; if (currentTracklist[prevIndex]) playAudioFile(currentTracklist[prevIndex], currentTracklist); else stopPlayback(true); }
         async function triggerDownload() { /* ... same logic ... */ /* Uses currentPlayingFile */ }


        // --- UI Updates ---
        function updatePlayerUI(isLoading = false, loadingMessage = 'Loading...') {
            const hasActiveTrack = !!currentPlayingFile;
            const durationKnown = hasActiveTrack && !isNaN(audioElement.duration) && audioElement.duration > 0;
            const canControl = hasActiveTrack && durationKnown && !isLoading; // Enable controls when duration is known

            // Enable/Disable core controls
            playPauseBtn.disabled = !hasActiveTrack || isLoading; // Enable as soon as track is set, even before duration known
            pitchSlider.disabled = !hasActiveTrack || isLoading; // Enable early like play/pause
            downloadBtn.disabled = !hasActiveTrack || isLoading || downloadBtn.classList.contains('loading');
            volumeSlider.disabled = false; // Volume always available
            prevBtn.disabled = !(currentTracklist && currentTracklist.length > 1 && currentTrackIndex !== -1); // Based on tracklist
            nextBtn.disabled = !(currentTracklist && currentTracklist.length > 1 && currentTrackIndex !== -1); // Based on tracklist
            progressWrapper.style.cursor = durationKnown ? 'pointer' : 'default'; // Allow seeking only when duration is known

            if (isLoading) { // Initial loading state when track is first selected
                albumArtLoader.classList.add('visible');
                albumArtIcon.classList.add('hidden');
                albumArtImg.classList.remove('loaded'); albumArtImg.src = '';
                // Metadata display handled by displayMetadataInPlayer called in playAudioFile
                playPauseBtn.textContent = '⏳'; // Show loading on button
                durationEl.textContent = '--:--';
                currentTimeEl.textContent = '--:--';
                progressBar.style.width = '0%';
                miniProgressBar.style.setProperty('--progress-width', '0%');
            } else if (hasActiveTrack) { // Track selected, might be playing/paused/buffering
                 // Metadata display handled by displayMetadataInPlayer
                 albumArtLoader.classList.remove('visible'); // Hide general loader (art has its own logic)
                 playPauseBtn.textContent = audioElement.paused ? '▶' : '⏸'; // Reflect actual state
                 if (durationKnown) {
                     durationEl.textContent = formatTime(audioElement.duration);
                 } else {
                     durationEl.textContent = '--:--'; // Show loading if duration unknown
                 }
                 updateProgress(); // Update current time and progress bar
            } else { // Default state (no track selected)
                 albumArtLoader.classList.remove('visible');
                 albumArtImg.classList.remove('loaded'); albumArtImg.src = '';
                 albumArtIcon.classList.remove('hidden');
                 nowPlayingEl.textContent = 'Not playing'; nowPlayingEl.title = 'Not playing';
                 nowPlayingArtistAlbumEl.textContent = 'Select an MP3 file'; nowPlayingArtistAlbumEl.title = 'Select an MP3 file';
                 nowPlayingPathEl.textContent = '';
                 playPauseBtn.textContent = '▶'; playPauseBtn.disabled = true;
                 pitchSlider.disabled = true; downloadBtn.disabled = true;
                 prevBtn.disabled = true; nextBtn.disabled = true;
                 durationEl.textContent = '0:00'; currentTimeEl.textContent = '0:00';
                 progressBar.style.width = '0%';
                 miniProgressBar.style.setProperty('--progress-width', '0%');
            }
        }
        function updateProgress() { /* Uses audioElement.currentTime / duration */ const currentTime = audioElement.currentTime || 0; const duration = audioElement.duration || 0; currentTimeEl.textContent = formatTime(currentTime); const progressPercent = (duration > 0 && !isNaN(duration)) ? (currentTime / duration) * 100 : 0; const progressWidth = `${Math.min(100, progressPercent)}%`; progressBar.style.width = progressWidth; if (miniProgressBar.style.getPropertyValue('--progress-width') !== progressWidth) { miniProgressBar.style.setProperty('--progress-width', progressWidth); } }
        function updateFileDurationInList(filePath, durationSeconds) { /* ... same ... */ if (currentLayoutMode !== 'list' || !durationSeconds || isNaN(durationSeconds)) return; const durationStr = formatTime(durationSeconds); const durationElement = fileBrowserContainerEl.querySelector(`.file-duration-list[data-path="${CSS.escape(filePath)}"]`); if (durationElement && durationElement.textContent !== durationStr) { durationElement.textContent = durationStr; } }
        function updateVolumeIcon(volume) { /* ... same ... */ volumeIcon.textContent = (volume <= 0) ? '🔇' : (volume < 0.5) ? '🔈' : '🔊'; }
        function updatePrevNextButtons() { /* Logic moved inside updatePlayerUI */ }

        // --- Minimizable Player & Body Padding ---
        function togglePlayerMinimized() { isPlayerMinimized = !isPlayerMinimized; applyMinimizedState(); saveSetting('playerMinimized', isPlayerMinimized); updateBodyPadding(); }
        function applyMinimizedState() { const toggleIcon = playerToggleBtn.querySelector('.toggle-icon'); if (isPlayerMinimized) { playerSection.classList.add('minimized'); if(toggleIcon) toggleIcon.textContent = '▲'; playerToggleBtn.title = "Expand Player"; } else { playerSection.classList.remove('minimized'); if(toggleIcon) toggleIcon.textContent = '▼'; playerToggleBtn.title = "Minimize Player"; } }
        function updateBodyPadding() { // Adjust body padding based on screen size and player state
            let playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-desktop').replace('px', ''));
            let toggleHeight = 0;
            if (window.matchMedia("(max-width: 768px)").matches) {
                playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-mobile-med').replace('px', ''));
                toggleHeight = parseInt(getComputedStyle(playerSection).getPropertyValue('--toggle-button-height').replace('px', ''));
            }
            if (window.matchMedia("(max-width: 480px)").matches) {
                playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-mobile-small').replace('px', ''));
                 toggleHeight = parseInt(getComputedStyle(playerSection).getPropertyValue('--toggle-button-height').replace('px', ''));
            }
            const totalPadding = playerHeight + (toggleHeight > 0 && !isPlayerMinimized ? toggleHeight : 0) + 20; // Add some extra buffer
            document.body.style.paddingBottom = `${totalPadding}px`;
        }

        // --- Helper Functions ---
        function formatTime(seconds) { /* ... same ... */ if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '0:00'; const totalSeconds = Math.floor(seconds); const mins = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }
        function showSearchHintIfNeeded() { /* ... same ... */ if (localStorage.getItem('searchHintDismissed') !== 'true') { setTimeout(() => searchHintPopup?.classList.add('visible'), 500); } }
        function dismissSearchHint() { /* ... same ... */ if (!searchHintPopup) return; searchHintPopup.style.opacity = '0'; setTimeout(() => searchHintPopup.classList.remove('visible'), 300); try { localStorage.setItem('searchHintDismissed', 'true'); } catch (e) { console.warn("Could not save hint dismissal state:", e); } }


        // --- Event Listeners ---
        function setupEventListeners() {
            // Search
             searchToggleBtn.addEventListener('click', () => toggleSearch());
             searchBox.addEventListener('input', handleSearch);
             searchBox.addEventListener('search', () => { if (!searchBox.value) handleSearch(); });

             // Keyboard Shortcuts
             document.addEventListener('keydown', (e) => {
                 const activeEl = document.activeElement;
                 const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
                 if (e.key === '/' && !isInputFocused) { e.preventDefault(); toggleSearch(true); }
                 else if (e.key === 'Escape' && searchContainer.classList.contains('active')) { toggleSearch(false); if (searchBox.value) { searchBox.value = ''; handleSearch(); } }
                 else if (e.code === 'Space' && !isInputFocused) { e.preventDefault(); if (!playPauseBtn.disabled) togglePlayback(); }
                 else if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isInputFocused && currentPlayingFile && !isNaN(audioElement.duration)) { e.preventDefault(); const seekDirection = e.key === 'ArrowLeft' ? -1 : 1; seek(seekDirection * SEEK_TIME_SECONDS); }
             });

            // Player Controls
            playPauseBtn.addEventListener('click', togglePlayback);
            prevBtn.addEventListener('click', playPrev);
            nextBtn.addEventListener('click', playNext);
            downloadBtn.addEventListener('click', triggerDownload);
            playerToggleBtn.addEventListener('click', togglePlayerMinimized);
            progressWrapper.addEventListener('click', (e) => { if (!currentPlayingFile || isNaN(audioElement.duration)) return; const rect = progressWrapper.getBoundingClientRect(); const clickX = e.clientX - rect.left; const progressRatio = Math.max(0, Math.min(1, clickX / rect.width)); const seekTime = progressRatio * audioElement.duration; console.log(`Seek click to: ${formatTime(seekTime)}`); audioElement.currentTime = seekTime; updateProgress(); });
            volumeSlider.addEventListener('input', () => { currentVolume = parseFloat(volumeSlider.value); audioElement.volume = currentVolume; updateVolumeIcon(currentVolume); saveSetting('playerVolume', currentVolume); });
            pitchSlider.addEventListener('input', () => { const newRate = parseFloat(pitchSlider.value); currentPlaybackRate = newRate; audioElement.playbackRate = newRate; saveSetting('playerRate', currentPlaybackRate); });

             // --- Audio Element Event Listeners ---
             audioElement.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); });
             audioElement.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); });
             audioElement.addEventListener('ended', () => { console.log("Audio ended event"); playNext(); });
             audioElement.addEventListener('timeupdate', updateProgress);
             audioElement.addEventListener('loadedmetadata', () => { console.log("Metadata loaded. Duration:", audioElement.duration); if (currentPlayingFile) updateFileDurationInList(currentPlayingFile.path, audioElement.duration); updatePlayerUI(); /* Enable controls now duration is known */ });
             audioElement.addEventListener('error', (e) => { console.error('Audio Element Error:', audioElement.error?.code, audioElement.error?.message); if(currentPlayingFile) { displayStatus(`Error playing ${currentPlayingFile.displayName}: ${audioElement.error?.message || 'Unknown playback error'}`, true); stopPlayback(true); } }); // Show error message
             audioElement.addEventListener('waiting', () => { updatePlayerUI(true, 'Buffering...'); }); // Show buffering state
             audioElement.addEventListener('canplay', () => { if(isPlaying) updatePlayerUI(); }); // Hide buffering state if playing

             // View Mode Toggles
             folderViewBtn.addEventListener('click', () => setMainViewMode(VIEW_MODE_FOLDER));
             artistViewBtn.addEventListener('click', () => setMainViewMode(VIEW_MODE_ARTIST));
             gridViewBtn.addEventListener('click', () => setLayoutMode('grid'));
             listViewBtn.addEventListener('click', () => setLayoutMode('list'));

             // Search Hint
             closeHintBtn.addEventListener('click', dismissSearchHint);

             // Update body padding on resize
             window.addEventListener('resize', updateBodyPadding);
        }

    </script>
</body>
</html>
