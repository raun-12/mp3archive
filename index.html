    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script>
        // --- Configuration ---
        const archiveIdentifier = 'mp3archive'; // <<< CHANGE THIS
        const archiveApiUrl = `https://archive.org/metadata/${archiveIdentifier}`;
        const archiveDownloadUrlBase = `https://archive.org/download/${archiveIdentifier}`;
        const excludedExtensions = [/*...*/];
        const FETCH_TIMEOUT_MS = 20000; // 20 seconds timeout for fetch
        const MAX_RETRIES = 2;
        const MAX_CACHE_SIZE = 15; // Max number of decoded audio buffers to cache
        const SEEK_TIME_SECONDS = 5; // How many seconds arrows seek

        // --- DOM Elements ---
        const searchToggleBtn = document.getElementById('search-toggle-btn');
        const searchContainer = document.getElementById('search-container');
        const searchBox = document.getElementById('search-box');
        const directoryPathEl = document.getElementById('directory-path');
        const fileBrowserContainerEl = document.getElementById('file-browser-container');
        const skeletonLoaderEl = document.getElementById('skeleton-loader'); // Added
        const statusMessageEl = document.getElementById('status-message');
        const playerSection = document.getElementById('player-section'); // Added
        const playerToggleBtn = document.getElementById('player-toggle-btn'); // Added
        const playerContentWrapper = document.querySelector('.player-content-wrapper'); // Added
        const miniProgressBar = document.getElementById('mini-progress-bar'); // Added
        const playerAlbumArt = document.getElementById('player-album-art');
        const albumArtImg = document.getElementById('album-art-img'); // Added
        const albumArtIcon = document.getElementById('album-art-icon'); // Added
        const albumArtLoader = playerAlbumArt.querySelector('.loader-overlay'); // Added
        const nowPlayingEl = document.getElementById('now-playing');
        const nowPlayingArtistAlbumEl = document.getElementById('now-playing-artist-album'); // Changed element
        const nowPlayingPathEl = document.getElementById('now-playing-path'); // Added
        const playPauseBtn = document.getElementById('play-pause-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const downloadBtn = document.getElementById('download-btn');
        const progressWrapper = document.getElementById('progress-wrapper');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeIcon = document.getElementById('volume-icon');
        const pitchSlider = document.getElementById('pitch-slider');
        const searchHintPopup = document.getElementById('search-hint-popup');
        const closeHintBtn = document.getElementById('close-hint-btn');
        const gridViewBtn = document.getElementById('grid-view-btn');
        const listViewBtn = document.getElementById('list-view-btn');

        // --- Audio State ---
        let audioContext;
        let sourceNode;
        let gainNode;
        let currentAudioBuffer;
        let isPlaying = false;
        let currentPlaybackRate = 1.0;
        let currentVolume = 0.7;
        let progressUpdateInterval;
        let _startTime = 0;
        let _startOffset = 0;
        let _pausedTime = 0;
        let fetchAbortController = null; // For cancelling fetches

        // --- Data State ---
        let currentDirectory = '';
        let allArchiveFiles = [];
        let currentDirectoryItems = [];
        let currentTracklist = [];
        let currentTrackIndex = -1;
        let currentPlayingFile = null; // { name, path, displayName, size, format, duration?, metadata? }
        let currentViewMode = localStorage.getItem('viewMode') || 'grid';
        let isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true'; // Persist minimized state

        // --- Caching ---
        const audioCache = new Map(); // Map<filePath, { buffer: AudioBuffer, metadata: object, timestamp: number }>
        const cacheOrder = []; // Array of filePaths for LRU-like eviction

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Load volume, rate, minimized state
            setupAudioContext();
            loadArchiveStructure(); // Will show skeletons now
            setupEventListeners();
            updatePlayerUI();
            applyViewMode();
            applyMinimizedState(); // Apply initial minimized state
            showSearchHintIfNeeded();
        });

        function loadSettings() {
             currentVolume = parseFloat(localStorage.getItem('playerVolume') || '0.7');
             currentPlaybackRate = parseFloat(localStorage.getItem('playerRate') || '1.0');
             isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true';

             volumeSlider.value = currentVolume;
             pitchSlider.value = currentPlaybackRate;
             updateVolumeIcon(currentVolume);
             // Minimized state applied in applyMinimizedState()
        }

        function saveSetting(key, value) {
             try {
                 localStorage.setItem(key, value);
             } catch (e) {
                 console.warn(`Could not save setting ${key}:`, e);
             }
        }

        function setupAudioContext() { /* ... same ... */ }

        // --- Archive.org API & Data Handling ---
        async function loadArchiveStructure() {
            showSkeletonLoader(true); // Show skeletons
            hideLoading(); // Hide text loader if shown previously
            statusMessageEl.classList.remove('visible');
            fileBrowserContainerEl.innerHTML = ''; // Clear file browser

            try {
                const response = await fetch(archiveApiUrl); // Add timeout/retry later if needed for metadata itself
                if (!response.ok) throw new Error(`Failed to load archive metadata (Status: ${response.status})`);
                const data = await response.json();

                if (!data.files || !Array.isArray(data.files)) {
                    throw new Error('Invalid archive structure: No files array found.');
                }

                // Process files (similar to before, maybe get duration from metadata if available)
                // ... (Existing processing logic, add duration if present) ...
                 const fileMap = new Map();
                 data.files.forEach(file => fileMap.set(file.name, file));

                 const processedFiles = data.files.map(file => {
                     const path = file.name;
                     let displayName = path.split('/').filter(p => p).pop() || path;
                     let isDirectory = path.endsWith('/');
                     if (!isDirectory) { /* ... check other files ... */
                          for (const otherPath of fileMap.keys()) {
                              if (otherPath !== path && otherPath.startsWith(path + '/')) {
                                  isDirectory = true;
                                  break;
                              }
                          }
                     }
                    // Get duration from metadata if possible (convert if needed)
                     let durationSeconds = undefined;
                     if (file.length && !isNaN(parseFloat(file.length))) {
                         durationSeconds = parseFloat(file.length);
                     }

                     return {
                         name: file.name,
                         path: path,
                         size: file.size ? parseInt(file.size) : 0,
                         format: file.format || '',
                         isDirectory: isDirectory,
                         isAudio: !isDirectory && path.toLowerCase().endsWith('.mp3'),
                         displayName: displayName, // Keep display name clean
                         duration: durationSeconds // Store duration from metadata
                     };
                 });
                 // ... filter and sort ...
                  allArchiveFiles = processedFiles
                    .filter(file => {
                        if (file.isDirectory) return true;
                        if (file.isAudio) {
                            const extension = file.path.substring(file.path.lastIndexOf('.')).toLowerCase();
                            return !excludedExtensions.includes(extension);
                        }
                        return false;
                    })
                    .sort((a, b) => {
                         if (a.isDirectory && !b.isDirectory) return -1;
                         if (!a.isDirectory && b.isDirectory) return 1;
                         return a.displayName.localeCompare(b.displayName);
                     });


                updateDirectoryView('');
                hideSkeletonLoader(); // Hide skeletons after processing

            } catch (error) {
                console.error('Error loading archive:', error);
                displayStatus(`Error loading archive structure: ${error.message}`, true);
                hideSkeletonLoader();
            }
        }

        // --- Skeleton Loader ---
        function showSkeletonLoader(show) {
            skeletonLoaderEl.style.display = show ? 'grid' : 'none'; // Use grid display for the skeleton container
            // Optional: Adjust skeleton class based on view mode if list skeletons are different
            // skeletonLoaderEl.className = `file-browser-${currentViewMode} visible`;
        }
        function hideSkeletonLoader() {
             skeletonLoaderEl.style.display = 'none';
        }


        // --- Directory Navigation & Display ---
        function updateDirectoryView(path) {
            showSkeletonLoader(true); // Show skeletons during view update
            fileBrowserContainerEl.innerHTML = ''; // Clear old content immediately
            currentDirectory = path;
            // ... (rest of the function: clear search, update breadcrumbs, get items) ...
             searchBox.value = '';
            if (searchContainer.classList.contains('active')) toggleSearch(false);
            updateBreadcrumbs();
            currentDirectoryItems = getItemsInDirectory(allArchiveFiles, path);

            // Update tracklist based on *audio files* in the current directory view
            currentTracklist = currentDirectoryItems.filter(item => item.isAudio);
            currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1;
            updatePrevNextButtons(); // Update based on new tracklist

            // Render after a tiny delay to allow UI to update (optional)
             requestAnimationFrame(() => {
                 renderFileBrowser(currentDirectoryItems); // Render using current view mode
                 hideSkeletonLoader(); // Hide skeletons after rendering
                 if (currentDirectoryItems.length === 0 && !searchBox.value) {
                     displayStatus("This directory is empty.", false);
                 } else if (currentDirectoryItems.length > 0) {
                      hideLoading(); // Hides the text status message if visible
                      statusMessageEl.classList.remove('visible');
                 }
             });
        }

        function getItemsInDirectory(allItems, dirPath) { /* ... same ... */ }
        function updateBreadcrumbs() { /* ... same ... */ }
        function createCrumb(text, path, isCurrent = false) { /* ... same ... */ }

        // --- View Mode Switching ---
        function setViewMode(mode) { /* ... same ... */ }
        function applyViewMode() { /* ... same ... */ }

        // --- File Rendering (Combined Logic) ---
        function renderFileBrowser(items) {
             // showSkeletonLoader(true); // Optional: show skeletons even for re-renders
             fileBrowserContainerEl.innerHTML = '';
             fileBrowserContainerEl.className = ''; // Clear old classes

             if (currentViewMode === 'list') {
                 fileBrowserContainerEl.classList.add('file-browser-list');
                 renderFileBrowserList(items);
             } else {
                 fileBrowserContainerEl.classList.add('file-browser-grid');
                 renderFileBrowserGrid(items);
             }
            // hideSkeletonLoader(); // Hide after rendering is complete

             // Update status if browser is empty after rendering
              if (items.length === 0 && !statusMessageEl.classList.contains('visible')) { // Only show if no other status is active
                 if(searchBox.value) {
                     displayStatus(`No MP3 files found matching "${searchBox.value}".`, false);
                 } else if (currentDirectory !== '' || allArchiveFiles.length > 0) { // Avoid showing "empty" before initial load finishes
                     displayStatus("This directory is empty.", false);
                 }
             } else if (items.length > 0) {
                 hideLoading(); // Hide text status message
                 statusMessageEl.classList.remove('visible');
             }
        }

        // --- Grid View Rendering ---
        function renderFileBrowserGrid(items) { /* ... same ... */ }

        // --- List View Rendering ---
        function renderFileBrowserList(items) {
             // Modify to include duration
             items.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = `file-item-list ${item.isAudio || item.isDirectory ? '' : 'non-interactive'}`;
                itemEl.dataset.path = item.path;

                const icon = document.createElement('div');
                icon.className = 'file-icon-list';
                if (item.isDirectory) icon.classList.add('folder');

                const nameEl = document.createElement('div');
                nameEl.className = 'file-name-list';
                nameEl.textContent = item.displayName || (item.isDirectory ? '[Folder]' : '[File]');
                nameEl.title = item.displayName || item.path;

                // Info container
                 const infoEl = document.createElement('div');
                 infoEl.className = 'file-info-list';

                 // Duration element (only for audio)
                 const durationEl = document.createElement('span');
                 durationEl.className = 'file-duration-list';
                 if(item.isAudio) {
                     // Use cached/metadata duration first, fallback needed if not available
                     durationEl.textContent = item.duration ? formatTime(item.duration) : '--:--';
                      // Store path on element to potentially fetch duration later if needed onClick (complex)
                     durationEl.dataset.path = item.path;
                 } else {
                     durationEl.textContent = ''; // No duration for folders/other
                 }

                 // Size element
                 const sizeEl = document.createElement('span');
                 sizeEl.className = 'file-size-list';
                 sizeEl.textContent = item.isDirectory ? 'Folder' : formatFileSize(item.size);

                 // Add icon based on type
                if (item.isDirectory) {
                    icon.textContent = 'ðŸ“';
                    itemEl.addEventListener('click', () => updateDirectoryView(item.path));
                } else if (item.isAudio) {
                    icon.textContent = 'ðŸŽµ';
                    itemEl.addEventListener('click', () => playAudioFile(item));
                } else {
                    icon.textContent = 'ðŸ“„';
                }

                itemEl.appendChild(icon);
                itemEl.appendChild(nameEl);
                 infoEl.appendChild(durationEl); // Add duration first visually
                 infoEl.appendChild(sizeEl);    // Then size
                itemEl.appendChild(infoEl);
                fileBrowserContainerEl.appendChild(itemEl);
            });
        }

        function formatFileSize(bytes) { /* ... same ... */ }

        // --- Search Functionality ---
        function toggleSearch(forceState) { /* ... same ... */ }
        function handleSearch() {
            showSkeletonLoader(true); // Show skeletons during search update
            fileBrowserContainerEl.innerHTML = '';
            const searchTerm = searchBox.value.toLowerCase().trim();

            if (!searchTerm) {
                updateDirectoryView(currentDirectory); // This handles skeletons
                return;
            }
             // Filter *all* files
            const results = allArchiveFiles.filter(file =>
                !file.isDirectory && file.isAudio && file.path.toLowerCase().includes(searchTerm)
            ).sort((a, b) => a.displayName.localeCompare(b.displayName));

            currentDirectoryItems = results; // Update the displayed items

            // Update tracklist for playback based on search results
            currentTracklist = results;
            currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1;
            updatePrevNextButtons();

            // Update breadcrumbs to show "Search Results"
            directoryPathEl.innerHTML = '';
            const searchCrumb = createCrumb(`Search: "${searchTerm}"`, '', true);
            directoryPathEl.appendChild(searchCrumb);

             // Render after a short delay
             requestAnimationFrame(() => {
                 renderFileBrowser(results);
                 hideSkeletonLoader();
                  if (results.length === 0) {
                      displayStatus(`No MP3 files found matching "${searchTerm}".`, false);
                  } else {
                       hideLoading(); // Hide text status
                       statusMessageEl.classList.remove('visible');
                  }
             });
        }


        // --- Metadata Handling ---
        async function getMetadata(file, arrayBuffer) {
            return new Promise((resolve) => {
                 // Only read tags if jsmediatags is loaded
                 if (typeof jsmediatags === 'undefined') {
                     console.warn("jsmediatags not loaded.");
                     resolve({}); // Return empty object
                     return;
                 }

                 jsmediatags.read(new Blob([arrayBuffer]), { // Read from the ArrayBuffer via Blob
                    onSuccess: function(tag) {
                        // console.log("Metadata Success:", tag);
                        const metadata = {
                            title: tag.tags.title,
                            artist: tag.tags.artist,
                            album: tag.tags.album,
                            picture: tag.tags.picture // { data: Uint8Array, format: string, description: string }
                        };
                        resolve(metadata);
                    },
                    onError: function(error) {
                        console.warn('Failed to read metadata:', file.path, error.type, error.info);
                        resolve({}); // Resolve with empty even on error
                    }
                });
            });
        }

        function displayMetadata(metadata) {
             const title = metadata?.title || currentPlayingFile?.displayName || 'Unknown Title';
             const artist = metadata?.artist;
             const album = metadata?.album;

             nowPlayingEl.textContent = title;
             nowPlayingEl.title = title; // Tooltip

             let artistAlbumText = [artist, album].filter(Boolean).join(' â€¢ '); // Join with bullet if both exist
             if (!artistAlbumText) {
                  // Fallback if no artist/album: show directory path in this line
                  const pathParts = currentPlayingFile?.path?.split('/').filter(p => p);
                  pathParts?.pop(); // Remove filename
                  artistAlbumText = pathParts?.length > 0 ? pathParts.join('/') : 'Unknown Source';
                  nowPlayingPathEl.textContent = ''; // Clear the small path line
             } else {
                 // Show directory path in the smaller line below if artist/album exists
                 const pathParts = currentPlayingFile?.path?.split('/').filter(p => p);
                 pathParts?.pop();
                 nowPlayingPathEl.textContent = pathParts?.length > 0 ? pathParts.join('/') : 'Root';
             }
             nowPlayingArtistAlbumEl.textContent = artistAlbumText || 'Unknown Artist/Album';
             nowPlayingArtistAlbumEl.title = artistAlbumText; // Tooltip

             // Handle Album Art
             albumArtLoader.style.display = 'none'; // Hide loader initially
             albumArtImg.style.display = 'none'; // Hide img initially
             albumArtIcon.style.opacity = '1'; // Show icon initially

             if (metadata?.picture) {
                 try {
                     const { data, format } = metadata.picture;
                     let base64String = "";
                     for (let i = 0; i < data.length; i++) {
                         base64String += String.fromCharCode(data[i]);
                     }
                     const imageUrl = `data:${format};base64,${window.btoa(base64String)}`;
                     albumArtImg.src = imageUrl;
                     albumArtImg.style.display = 'block'; // Show image
                     albumArtIcon.style.opacity = '0'; // Hide icon
                 } catch (e) {
                     console.error("Error displaying album art:", e);
                     albumArtImg.style.display = 'none';
                     albumArtIcon.style.opacity = '1';
                 }
             }
        }

        // --- Caching Logic ---
        function manageCache(filePath, data) {
             if (audioCache.size >= MAX_CACHE_SIZE) {
                 const oldestPath = cacheOrder.shift(); // Get the oldest path
                 if (oldestPath) {
                     audioCache.delete(oldestPath);
                     // console.log("Cache evicted:", oldestPath);
                 }
             }
             audioCache.set(filePath, { ...data, timestamp: Date.now() });
             cacheOrder.push(filePath); // Add new path to the end
             // console.log("Cached:", filePath, "Size:", audioCache.size);
        }

        function clearCache() {
            audioCache.clear();
            cacheOrder.length = 0;
            console.log("Audio cache cleared.");
        }


        // --- Audio Playback (Modified) ---
         async function playAudioFile(file) {
            if (!file || !file.isAudio) return;
            if (!audioContext) { alert("Audio system not ready. Click page first."); return; }

            console.log("Requesting:", file.path);
            stopPlayback(); // Stop current playback and clear resources

            currentPlayingFile = file;
            currentTrackIndex = currentTracklist.findIndex(track => track.path === file.path);
            updatePlayerUI(true, 'Connecting...'); // Show loading immediately

             // 1. Check Cache
             if (audioCache.has(file.path)) {
                 console.log("Playing from cache:", file.path);
                 const cachedData = audioCache.get(file.path);
                 currentAudioBuffer = cachedData.buffer;
                 currentPlayingFile.metadata = cachedData.metadata; // Use cached metadata
                 currentPlayingFile.duration = currentAudioBuffer.duration; // Update duration from buffer

                 displayMetadata(cachedData.metadata); // Display cached metadata
                 startPlayback(0);
                 updatePlayerUI(); // Update UI after starting playback
                 updatePrevNextButtons();
                 updateFileDurationInList(file.path, currentAudioBuffer.duration); // Update list view duration
                 return; // Exit function, played from cache
             }

             // 2. Fetch and Process (with timeout and retry)
             updatePlayerUI(true, 'Downloading...');
             albumArtLoader.style.display = 'block'; // Show loader over album art area
             albumArtIcon.style.opacity = '0'; // Hide icon behind loader

             try {
                 const arrayBuffer = await fetchWithTimeoutAndRetry(`${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`, FETCH_TIMEOUT_MS, MAX_RETRIES);

                 if (!currentPlayingFile || file.path !== currentPlayingFile.path) return; // Check if selection changed during fetch

                 updatePlayerUI(true, 'Decoding...');

                 // Decode Audio Data
                 const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0)); // Use slice to avoid potential modification issues
                 if (!currentPlayingFile || file.path !== currentPlayingFile.path) return;

                 currentAudioBuffer = decodedBuffer;
                 currentPlayingFile.duration = currentAudioBuffer.duration; // Update duration from decoded buffer

                  // Get Metadata (async, but wait for it before caching/playing)
                  updatePlayerUI(true, 'Reading Tags...');
                  const metadata = await getMetadata(file, arrayBuffer);
                  currentPlayingFile.metadata = metadata; // Store metadata

                  // Cache the data
                  manageCache(file.path, { buffer: currentAudioBuffer, metadata: metadata });

                  // Display and Play
                  displayMetadata(metadata);
                  startPlayback(0);
                  updatePlayerUI();
                  updatePrevNextButtons();
                  updateFileDurationInList(file.path, currentAudioBuffer.duration);


             } catch (error) {
                 console.error(`Error processing audio file ${file.path}:`, error);
                 if (currentPlayingFile && file.path === currentPlayingFile.path) {
                      displayStatus(`Error playing ${file.displayName}: ${error.message}`, true);
                     stopPlayback(true); // Clear info on error
                 }
             }
        }

        // Fetch helper with timeout and retry
        async function fetchWithTimeoutAndRetry(url, timeout, retries) {
             let attempts = 0;
             while (attempts <= retries) {
                 attempts++;
                 if (fetchAbortController) { // Abort previous fetch if any
                     fetchAbortController.abort();
                 }
                 fetchAbortController = new AbortController();
                 const { signal } = fetchAbortController;
                 const timeoutId = setTimeout(() => fetchAbortController.abort(), timeout);

                 try {
                      if (attempts > 1) {
                         console.log(`Retrying fetch for ${url} (Attempt ${attempts})...`);
                         updatePlayerUI(true, `Retrying (${attempts}/${retries})...`);
                         // Optional: small delay before retry
                         await new Promise(resolve => setTimeout(resolve, 500));
                      }

                     const response = await fetch(url, { signal });
                     clearTimeout(timeoutId); // Clear timeout if fetch resolves/rejects normally

                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
                     }
                     const arrayBuffer = await response.arrayBuffer();
                     fetchAbortController = null; // Clear controller on success
                     return arrayBuffer;

                 } catch (error) {
                     clearTimeout(timeoutId); // Clear timeout on error too
                     fetchAbortController = null; // Clear controller

                     if (error.name === 'AbortError') {
                         console.error(`Fetch timed out for ${url} after ${timeout}ms.`);
                         if (attempts > retries) throw new Error(`Fetch timed out after ${retries + 1} attempts.`);
                         // Continue to next retry attempt
                     } else {
                         console.error(`Fetch error for ${url}:`, error);
                         if (attempts > retries) throw error; // Throw error if max retries reached
                         // Continue to next retry attempt for other errors too
                     }
                 }
             }
             // Should not be reached if retries exhausted, error would be thrown
             throw new Error("Fetch failed after multiple retries.");
         }


         function cleanupPlaybackResources() {
             clearInterval(progressUpdateInterval);
             progressUpdateInterval = null;
             if (sourceNode) {
                 try {
                     sourceNode.onended = null;
                     sourceNode.stop();
                 } catch (e) {}
                 sourceNode.disconnect();
                 sourceNode = null;
             }
             // Abort any ongoing fetch for the *next* track if implemented
             if (fetchAbortController) {
                 fetchAbortController.abort("Playback stopped");
                 fetchAbortController = null;
             }
         }

        function startPlayback(offset = 0) {
            if (!currentAudioBuffer || !audioContext || !gainNode) return;

            cleanupPlaybackResources(); // Clean up previous resources first

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = currentAudioBuffer;
            sourceNode.playbackRate.value = currentPlaybackRate;
            sourceNode.connect(gainNode);

            const validOffset = Math.max(0, Math.min(offset, currentAudioBuffer.duration));
            _startOffset = validOffset;
            _startTime = audioContext.currentTime; // Time playback *actually* starts
            _pausedTime = 0; // Reset paused time when starting

            sourceNode.start(0, validOffset);
            isPlaying = true;

            sourceNode.onended = handleTrackEnd;

            progressUpdateInterval = setInterval(updateProgress, 250); // Use shorter interval?
            updatePlayerUI(); // Update UI to playing state
        }

        function stopPlayback(clearInfo = false) {
             if (isPlaying) {
                 _pausedTime = getCurrentPlaybackTime(); // Store position *before* cleaning up
             }
             isPlaying = false;
             cleanupPlaybackResources(); // Clean up nodes, intervals, fetches

             if (clearInfo) {
                 currentPlayingFile = null;
                 currentAudioBuffer = null;
                 currentTrackIndex = -1;
                 _startOffset = 0;
                 _pausedTime = 0; // Reset time if clearing info
                 updatePlayerUI(); // Reset UI completely
                 updatePrevNextButtons();
             } else if (currentAudioBuffer) {
                 // If just pausing, update UI to reflect paused state and time
                 updatePlayerUI();
                 updateProgress(); // Ensure progress bar shows paused time
             } else {
                  // If no buffer (e.g., error occurred or initial state)
                  updatePlayerUI(); // Ensure UI resets to default
             }
        }


        function togglePlayback() {
            if (!currentAudioBuffer || !audioContext) return;
            if (isPlaying) {
                stopPlayback(false); // Pause
            } else {
                const resumeTime = (_pausedTime > 0 && _pausedTime < currentAudioBuffer.duration) ? _pausedTime : 0;
                startPlayback(resumeTime); // Play/Resume
            }
        }

        function handleTrackEnd() {
            // Called when sourceNode naturally finishes
            console.log("Track ended naturally.");
             _startOffset = 0;
             _pausedTime = currentAudioBuffer ? currentAudioBuffer.duration : 0; // Set to end
             _startTime = 0;
             isPlaying = false; // Set playing state correctly
             cleanupPlaybackResources(); // Clean up interval etc.

             updateProgress(); // Show final time
             updatePlayerUI(); // Update buttons etc.
             playNext(); // Auto-play next
        }

        function seek(offsetSeconds) {
             if (!currentAudioBuffer || !audioContext) return;

             const currentPosition = getCurrentPlaybackTime();
             let seekTime = currentPosition + offsetSeconds;
             seekTime = Math.max(0, Math.min(seekTime, currentAudioBuffer.duration)); // Clamp within bounds

             console.log(`Seeking by ${offsetSeconds}s to: ${formatTime(seekTime)}`);

             _pausedTime = seekTime; // Update target time

             if (isPlaying) {
                 startPlayback(seekTime); // Stop current and restart at seekTime
             } else {
                 // If paused, just update the visual progress
                 updateProgress();
             }
         }


         function playNext() { /* ... same ... */ }
         function playPrev() { /* ... same ... */ }
         async function triggerDownload() { /* ... same ... */ }


        // --- UI Updates ---
        function updatePlayerUI(isLoading = false, loadingMessage = 'Loading...') {
             const hasActiveTrack = !!currentPlayingFile;
             const hasBuffer = !!currentAudioBuffer;
             const canControl = hasActiveTrack && hasBuffer && !isLoading;

             // Basic Controls
             playPauseBtn.disabled = !hasActiveTrack || isLoading || !audioContext;
             pitchSlider.disabled = !canControl;
             downloadBtn.disabled = !canControl || downloadBtn.classList.contains('loading');
             volumeSlider.disabled = !audioContext; // Volume always available if context exists
             updatePrevNextButtons();

             // Player Info Display
             if (isLoading) {
                 albumArtLoader.style.display = 'block'; // Show loader over art
                 albumArtIcon.style.opacity = '0';
                 albumArtImg.style.display = 'none';

                 nowPlayingEl.textContent = currentPlayingFile?.displayName || 'Loading...';
                 nowPlayingArtistAlbumEl.textContent = loadingMessage;
                 nowPlayingPathEl.textContent = ''; // Clear path during load
                 playPauseBtn.textContent = 'â³';
                 durationEl.textContent = '--:--';
                 currentTimeEl.textContent = '--:--';
                 progressBar.style.width = '0%';
                 miniProgressBar.style.setProperty('--progress-width', '0%');

             } else if (hasActiveTrack && hasBuffer) {
                 // Metadata display is handled by displayMetadata() called elsewhere
                 // Ensure it's called if playing from cache or after fetch
                 if (!currentPlayingFile.metadata) { // If somehow metadata is missing, display basic info
                     displayMetadata({}); // Show default titles
                 } else {
                     // Metadata should have been displayed already by playAudioFile
                 }
                 albumArtLoader.style.display = 'none'; // Hide art loader

                 playPauseBtn.textContent = isPlaying ? 'â¸' : 'â–¶';
                 durationEl.textContent = formatTime(currentAudioBuffer.duration);
                 updateProgress(); // Update time/progress bar

             } else { // Default state
                 albumArtLoader.style.display = 'none';
                 albumArtImg.style.display = 'none';
                 albumArtIcon.style.opacity = '1';

                 nowPlayingEl.textContent = 'Not playing';
                 nowPlayingArtistAlbumEl.textContent = 'Select an MP3 file to play';
                 nowPlayingPathEl.textContent = '';
                 playPauseBtn.textContent = 'â–¶';
                 playPauseBtn.disabled = true;
                 pitchSlider.disabled = true;
                 downloadBtn.disabled = true;
                 prevBtn.disabled = true;
                 nextBtn.disabled = true;
                 durationEl.textContent = '0:00';
                 currentTimeEl.textContent = '0:00';
                 progressBar.style.width = '0%';
                 miniProgressBar.style.setProperty('--progress-width', '0%');
             }
         }

        function updateProgress() {
            if (!audioContext || !currentAudioBuffer) {
                currentTimeEl.textContent = '0:00';
                progressBar.style.width = '0%';
                if(miniProgressBar) miniProgressBar.style.setProperty('--progress-width', `0%`); // Update mini bar too
                return;
            }
            const currentPosition = getCurrentPlaybackTime();
            const duration = currentAudioBuffer.duration;

            currentTimeEl.textContent = formatTime(currentPosition);
            const progressPercent = (duration > 0) ? (currentPosition / duration) * 100 : 0;
            progressBar.style.width = `${Math.min(100, progressPercent)}%`;

            // Update mini progress bar (more efficient way)
            if (miniProgressBar) {
                 const miniPercent = `${Math.min(100, progressPercent)}%`;
                 // Avoid constant style recalculation if value is the same
                 if (miniProgressBar.style.getPropertyValue('--progress-width') !== miniPercent) {
                    miniProgressBar.style.setProperty('--progress-width', miniPercent);
                 }
            }
        }

         function updateFileDurationInList(filePath, durationSeconds) {
             if (currentViewMode !== 'list' || !durationSeconds) return;
             const durationStr = formatTime(durationSeconds);
             const durationElement = fileBrowserContainerEl.querySelector(`.file-duration-list[data-path="${CSS.escape(filePath)}"]`);
             if (durationElement && durationElement.textContent !== durationStr) {
                 durationElement.textContent = durationStr;
             }
         }

        function updateVolumeIcon(volume) { /* ... same ... */ }
        function updatePrevNextButtons() { /* ... same ... */ }

        // --- Minimizable Player ---
        function togglePlayerMinimized() {
            isPlayerMinimized = !isPlayerMinimized;
            applyMinimizedState();
            saveSetting('playerMinimized', isPlayerMinimized);
        }

        function applyMinimizedState() {
             const toggleIcon = playerToggleBtn.querySelector('.toggle-icon');
            if (isPlayerMinimized) {
                playerSection.classList.add('minimized');
                 if(toggleIcon) toggleIcon.textContent = 'â–²';
                 playerToggleBtn.title = "Expand Player";
            } else {
                playerSection.classList.remove('minimized');
                 if(toggleIcon) toggleIcon.textContent = 'â–¼';
                 playerToggleBtn.title = "Minimize Player";
            }
        }


        // --- Helper Functions ---
        function formatTime(seconds) { /* ... same ... */ }
        function displayStatus(message, isError = false) { /* ... same ... */ }
        function showLoading(message = "Loading...") { /* ... same ... */ }
        function hideLoading() { /* ... same ... */ }
        function showSearchHintIfNeeded() { /* ... same ... */ }
        function dismissSearchHint() { /* ... same ... */ }


        // --- Event Listeners ---
        function setupEventListeners() {
            // Search box toggle & activation
             searchToggleBtn.addEventListener('click', () => toggleSearch());
             document.addEventListener('keydown', (e) => {
                 const activeEl = document.activeElement;
                 const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);

                 // '/' for search (if not typing)
                 if (e.key === '/' && !isInputFocused) {
                    e.preventDefault();
                    toggleSearch(true);
                 }
                 // Escape for search
                 else if (e.key === 'Escape' && searchContainer.classList.contains('active')) {
                     toggleSearch(false);
                     if (searchBox.value) { searchBox.value = ''; handleSearch(); } // Clear and update view
                 }
                 // Space for Play/Pause (if not typing)
                 else if (e.code === 'Space' && !isInputFocused) {
                     e.preventDefault();
                     if (!playPauseBtn.disabled) {
                         togglePlayback();
                     }
                 }
                 // Arrow Left/Right for Seek (if not typing and track loaded)
                 else if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isInputFocused && currentAudioBuffer) {
                      e.preventDefault();
                      const seekDirection = e.key === 'ArrowLeft' ? -1 : 1;
                      seek(seekDirection * SEEK_TIME_SECONDS);
                 }
                 // Arrow Up/Down could be volume? - Add if desired
                 // else if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && !isInputFocused && audioContext) {
                 //     e.preventDefault();
                 //     const volumeStep = 0.05;
                 //     let newVolume = currentVolume + (e.key === 'ArrowUp' ? volumeStep : -volumeStep);
                 //     newVolume = Math.max(0, Math.min(1, newVolume));
                 //     volumeSlider.value = newVolume;
                 //     // Manually trigger input event to update gain node and icon
                 //     volumeSlider.dispatchEvent(new Event('input'));
                 // }

             });
             searchBox.addEventListener('input', handleSearch);
             searchBox.addEventListener('search', () => { if (!searchBox.value) handleSearch(); });

            // Player controls
            playPauseBtn.addEventListener('click', togglePlayback);
            prevBtn.addEventListener('click', playPrev);
            nextBtn.addEventListener('click', playNext);
            downloadBtn.addEventListener('click', triggerDownload);

            // Player Minimize Toggle
             playerToggleBtn.addEventListener('click', togglePlayerMinimized);


            // Progress bar seeking
             progressWrapper.addEventListener('click', (e) => {
                 if (!currentAudioBuffer || !audioContext) return;
                 const rect = progressWrapper.getBoundingClientRect();
                 const clickX = e.clientX - rect.left;
                 const progressRatio = Math.max(0, Math.min(1, clickX / rect.width));
                 const seekTime = progressRatio * currentAudioBuffer.duration;

                 _pausedTime = seekTime; // Update target time

                 if (isPlaying) {
                     startPlayback(seekTime); // Stop current and restart
                 } else {
                     updateProgress(); // Update visual if paused
                 }
             });

            // Volume control + Persistence
             volumeSlider.addEventListener('input', () => {
                 currentVolume = parseFloat(volumeSlider.value);
                 if (gainNode) gainNode.gain.value = currentVolume;
                 updateVolumeIcon(currentVolume);
                 saveSetting('playerVolume', currentVolume); // Save on change
             });

            // Pitch/Speed control + Persistence
             pitchSlider.addEventListener('input', () => {
                 const newRate = parseFloat(pitchSlider.value);
                 if (newRate === currentPlaybackRate) return;
                 currentPlaybackRate = newRate;
                 if (sourceNode) {
                     const currentTime = getCurrentPlaybackTime(); // Get time *before* rate change
                     sourceNode.playbackRate.setValueAtTime(currentPlaybackRate, audioContext.currentTime);
                     // Adjust timing if playing
                     if (isPlaying) {
                         _startOffset = currentTime;
                         _startTime = audioContext.currentTime;
                     }
                 }
                 saveSetting('playerRate', currentPlaybackRate); // Save on change
             });

            // View Mode Toggles
            gridViewBtn.addEventListener('click', () => setViewMode('grid'));
            listViewBtn.addEventListener('click', () => setViewMode('list'));

            // Search Hint Popup Close Button
            closeHintBtn.addEventListener('click', dismissSearchHint);

             // Optional: Clear cache on page unload/close?
             // window.addEventListener('beforeunload', clearCache);
        }

    </script>
</body>
