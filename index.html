<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 Archive Streamer</title>
    <!-- jsmediatags Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <style>
        /* --- Apple Music-inspired Dark Theme --- */
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #282828;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-color: #ff375f;
            --accent-hover: #ff5375;
            --progress-bar: #535353;
            --progress-filled: #ff375f;
            --volume-track: #535353;
            --volume-thumb: #ffffff;
            --border-color: #2a2a2a;
            --highlight-color: rgba(255, 55, 95, 0.3);
            --card-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            --player-shadow: 0 -8px 24px rgba(0, 0, 0, 0.7);
            --hint-bg: #282828;
            --hint-text: #e0e0e0;
            --button-bg-hover: rgba(255, 255, 255, 0.1);
            --skeleton-bg: #2a2a2a;
            --skeleton-highlight: #383838;
            --list-item-hover: var(--bg-tertiary);
            --player-height-desktop: 90px;
            --player-height-mobile-med: 190px; /* Increased */
            --player-height-mobile-small: 210px; /* Increased */
            --toggle-button-height: 25px;
        }

        /* --- Base Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            /* Adjusted padding-bottom dynamically via JS if needed */
            padding: 0 0 var(--player-height-desktop) 0; /* Default padding */
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* --- Header --- */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0; /* Reduced padding */
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header h1 { margin: 0; font-size: 1.8rem; /* Slightly smaller */ background: linear-gradient(90deg, #ff375f, #ff6b8b); -webkit-background-clip: text; background-clip: text; color: transparent; flex-shrink: 0; order: 1; }
        .search-area { display: flex; align-items: center; gap: 10px; flex-grow: 1; justify-content: flex-end; order: 3; /* Moved search to end */ }
        .header-icon-button { background: none; border: none; color: var(--text-primary); font-size: 1.3rem; cursor: pointer; padding: 8px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; flex-shrink: 0; line-height: 1; }
        .header-icon-button:hover { background-color: var(--button-bg-hover); }
        .search-container { position: relative; width: 0; opacity: 0; transition: width 0.3s ease, opacity 0.3s ease; overflow: hidden; visibility: hidden; max-width: 300px; }
        .search-container.active { width: 100%; opacity: 1; visibility: visible; }
        #search-box { width: 100%; padding: 10px 15px 10px 40px; border: none; border-radius: 20px; background-color: var(--bg-tertiary); color: var(--text-primary); font-size: 0.9rem; outline: none; box-sizing: border-box; }
        .search-icon-input { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); pointer-events: none; }

        /* --- Main View Toggle Buttons --- */
        .main-view-toggle {
             order: 2; /* Position between title and search */
             display: flex;
             gap: 5px;
             background-color: var(--bg-tertiary);
             padding: 4px;
             border-radius: 6px;
             flex-shrink: 0;
        }
        .main-view-btn {
            background: none; border: none; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500; cursor: pointer; padding: 4px 10px; border-radius: 4px; transition: background-color 0.2s, color 0.2s; line-height: 1.2;
        }
        .main-view-btn:hover { color: var(--text-primary); }
        .main-view-btn.active { background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }


        /* --- Controls Bar (Breadcrumbs / Grid-List Toggle) --- */
         .controls-bar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; min-height: 30px; /* Ensure space even if empty */ }
         .directory-container { overflow-x: auto; white-space: nowrap; padding-bottom: 5px; flex-grow: 1; min-width: 200px; }
         .directory-path { display: inline-flex; gap: 5px; align-items: center; }
         .directory-crumb { color: var(--text-secondary); font-size: 0.9rem; cursor: pointer; transition: color 0.2s, background-color 0.2s; padding: 2px 4px; border-radius: 3px; }
         .directory-crumb:hover { color: var(--text-primary); background-color: var(--bg-tertiary); text-decoration: none; }
         .directory-crumb.current { color: var(--text-primary); font-weight: 500; cursor: default; }
         .directory-crumb.current:hover { background-color: transparent; }
         .directory-separator { color: var(--text-secondary); font-size: 0.9rem; margin: 0 2px; }
         .view-toggle-buttons { display: flex; gap: 5px; background-color: var(--bg-tertiary); padding: 4px; border-radius: 6px; flex-shrink: 0; }
         .view-toggle-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.1rem; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s, color 0.2s; line-height: 1; }
         .view-toggle-btn:hover { color: var(--text-primary); }
         .view-toggle-btn.active { background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }


        /* --- Skeleton Loader Styles --- */
        .skeleton { background-color: var(--bg-secondary); border-color: var(--border-color); pointer-events: none; position: relative; overflow: hidden; }
        .skeleton::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, var(--skeleton-highlight), transparent); animation: skeleton-shine 1.5s infinite linear; }
        @keyframes skeleton-shine { 0% { left: -100%; } 100% { left: 100%; } }
        /* Grid Skeleton Item */
        .file-item-grid.skeleton { display: flex; flex-direction: column; align-items: center; text-align: center; padding: 15px; border-radius: 8px; border: 1px solid transparent; }
        .skeleton-icon { width: 40px; height: 40px; background-color: var(--skeleton-bg); border-radius: 4px; margin-bottom: 12px; }
        .skeleton-text { width: 80%; height: 1em; background-color: var(--skeleton-bg); border-radius: 3px; margin-bottom: 8px; }
        .skeleton-text.short { width: 50%; height: 0.8em; }
        /* List Skeleton Item */
        .file-item-list.skeleton { height: 45px; display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 5px; }
        .file-browser-list .skeleton-icon { width: 20px; height: 20px; margin-bottom: 0; flex-shrink: 0; }
        .file-browser-list .skeleton-text { height: 0.9em; margin-bottom: 0; flex-grow: 1; }
        .file-browser-list .skeleton-text.short { width: 50px; flex-grow: 0; flex-shrink: 0; margin-left: auto; }


        /* --- Generic Browser Container --- */
        #file-browser-container { margin-top: 10px; }

        /* --- File Browser (Grid View) --- */
        .file-browser-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; }
        .file-item-grid { background-color: var(--bg-secondary); border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.2s ease-in-out; border: 1px solid var(--border-color); overflow: hidden; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .file-item-grid:hover { background-color: var(--list-item-hover); transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); }
        .file-icon-grid { font-size: 2.5rem; margin-bottom: 12px; color: var(--accent-color); line-height: 1; }
        .file-icon-grid.folder, .file-icon-grid.artist, .file-icon-grid.album { color: #77aaff; } /* Blue for containers */
        .file-name-grid { font-size: 0.9rem; font-weight: 500; white-space: normal; overflow-wrap: break-word; word-break: break-all; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; margin-bottom: 5px; max-height: calc(1.3em * 3); }
        .file-info-grid { font-size: 0.75rem; color: var(--text-secondary); margin-top: auto; }


         /* --- File Browser (List View) --- */
         .file-browser-list { display: flex; flex-direction: column; gap: 2px; }
         .file-item-list { display: flex; align-items: center; padding: 10px 12px; background-color: var(--bg-secondary); border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease-in-out; border: 1px solid transparent; gap: 12px; }
         .file-item-list:hover { background-color: var(--list-item-hover); border-color: var(--border-color); }
         .file-item-list.non-interactive { cursor: default; opacity: 0.6; }
         .file-item-list.non-interactive:hover { background-color: var(--bg-secondary); border-color: transparent; }
         .file-icon-list { font-size: 1.2rem; color: var(--accent-color); line-height: 1; width: 20px; text-align: center; flex-shrink: 0; }
         .file-icon-list.folder, .file-icon-list.artist, .file-icon-list.album { color: #77aaff; } /* Blue for containers */
         .file-name-list { font-size: 0.95rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; line-height: 1.3; }
         .file-info-list { display: flex; justify-content: flex-end; gap: 10px; min-width: 100px; text-align: right; flex-shrink: 0; }
         .file-duration-list { font-size: 0.8rem; color: var(--text-secondary); width: 45px; text-align: right; flex-shrink: 0; }
         .file-size-list { font-size: 0.8rem; color: var(--text-secondary); min-width: 55px; text-align: right; flex-shrink: 0; }
         .file-item-count { /* For artist/album info */ font-size: 0.8rem; color: var(--text-secondary); margin-left: auto; /* Push to right */ flex-shrink: 0; padding-left: 15px; }


        /* --- Player Section --- */
        #player-section { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 0; /* Padding removed, handled by wrapper */ box-shadow: var(--player-shadow); border-top: 1px solid var(--border-color); z-index: 100; transition: height 0.3s ease, transform 0.3s ease; height: var(--player-height-desktop); overflow: hidden; }
        .player-toggle-button { position: absolute; top: calc(-1 * var(--toggle-button-height)); /* Position above */ left: 50%; transform: translateX(-50%); background-color: rgba(40, 40, 40, 0.9); border: 1px solid var(--border-color); border-bottom: none; color: var(--text-secondary); width: 50px; height: var(--toggle-button-height); border-radius: 8px 8px 0 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; z-index: 101; transition: background-color 0.2s; padding: 0; display: none; /* Hidden on desktop by default */ }
        .player-toggle-button:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .player-toggle-button .toggle-icon { transition: transform 0.3s ease; }
        .mini-progress { position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background-color: var(--progress-bar); display: none; z-index: 102; pointer-events: none; }
        .mini-progress::after { content: ''; position: absolute; left: 0; top: 0; height: 100%; background-color: var(--progress-filled); width: var(--progress-width, 0%); transition: width 0.1s linear; }
        .player-content-wrapper { display: flex; align-items: center; justify-content: space-between; width: 100%; height: 100%; gap: 15px; transition: opacity 0.3s ease; padding: 15px 20px; /* Padding applied here */ box-sizing: border-box; }
        .player-info { display: flex; align-items: center; gap: 15px; width: 25%; min-width: 150px; overflow: hidden; }
        .player-album-art { position: relative; width: 50px; height: 50px; background-color: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; flex-shrink: 0; color: var(--accent-color); overflow: hidden; }
        .player-album-art img { display: block; width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.3s ease; }
        .player-album-art img.loaded { opacity: 1; }
        .player-album-art #album-art-icon { position: relative; z-index: 1; transition: opacity 0.3s ease; }
        .player-album-art #album-art-icon.hidden { opacity: 0; }
        .player-album-art .loader-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; /* Hidden by default */ align-items: center; justify-content: center; z-index: 2; }
        .player-album-art .loader-overlay.visible { display: flex; }
        .player-album-art .loader-overlay .loader { margin: 0; }
        .player-text { min-width: 0; overflow: hidden; }
        .player-title { font-size: 0.95rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
        .player-subtitle { /* Artist - Album */ font-size: 0.8rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .player-subtitle-small { /* Path */ font-size: 0.7rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; opacity: 0.8; margin-top: 2px; }
        .player-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 50%; max-width: 500px; }
        .player-buttons { display: flex; align-items: center; gap: 15px; }
        .player-button { background: none; border: none; color: var(--text-primary); font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; line-height: 1; position: relative; }
        .player-button:disabled { opacity: 0.4; cursor: not-allowed; }
        .player-button:not(:disabled):hover { background-color: var(--button-bg-hover); }
        #download-btn { font-size: 1.1rem; }
        #download-btn .btn-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 18px; height: 18px; border-width: 2px; display: none; }
        #download-btn.loading .btn-icon { visibility: hidden; }
        #download-btn.loading .btn-loader { display: inline-block; }
        .play-pause-btn { background-color: var(--accent-color); width: 44px; height: 44px; }
        .play-pause-btn:not(:disabled):hover { background-color: var(--accent-hover); transform: scale(1.05); }
        .progress-container { width: 100%; display: flex; align-items: center; gap: 10px; }
        .progress-time { font-size: 0.75rem; color: var(--text-secondary); min-width: 40px; text-align: center; }
        .progress-bar-wrapper { flex-grow: 1; height: 12px; display: flex; align-items: center; cursor: pointer; padding: 4px 0; }
        .progress-bar-container { width: 100%; height: 4px; background-color: var(--progress-bar); border-radius: 2px; overflow: hidden; position: relative; }
        .progress-bar { height: 100%; background-color: var(--progress-filled); border-radius: 2px; width: 0%; position: absolute; left: 0; top: 0; transition: width 0.1s linear;}
        .progress-bar-wrapper:hover .progress-bar { background-color: var(--accent-hover); }
        .player-extras { display: flex; align-items: center; gap: 10px; width: 25%; justify-content: flex-end; min-width: 150px; flex-wrap: wrap; }
        .pitch-control { display: flex; align-items: center; gap: 5px; min-width: fit-content; } /* Reduced gap */
        .volume-control { display: flex; align-items: center; gap: 8px; min-width: 120px; }
        .control-label { font-size: 0.8rem; color: var(--text-secondary); min-width: 35px; text-align: right; flex-shrink: 0; }
        .control-slider { width: 70px; height: 4px; appearance: none; background-color: var(--volume-track); border-radius: 2px; outline: none; cursor: pointer; transition: background-color 0.2s; }
        .control-slider:hover { background-color: #6a6a6a; }
        .control-slider::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; transition: transform 0.1s; }
        .control-slider:active::-webkit-slider-thumb { transform: scale(1.2); }
        .control-slider::-moz-range-thumb { width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; border: none; }
        .volume-icon { color: var(--text-secondary); font-size: 1rem; width: 20px; text-align: center; }
        /* Reset Speed Button */
        .reset-speed-button {
            width: 28px; height: 28px; font-size: 0.8rem; padding: 2px; min-width: unset; margin-left: 5px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); display: none; /* Hidden by default */
        }
        .reset-speed-button:not(:disabled):hover { background-color: var(--bg-secondary); }

        /* Minimized Player State */
        #player-section.minimized { height: 35px; padding: 0; }
        #player-section.minimized .player-content-wrapper { opacity: 0; pointer-events: none; }
        #player-section.minimized .mini-progress { display: block; }
        #player-section.minimized .player-info { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 15px; background-color: rgba(30, 30, 30, 0.9); opacity: 1; pointer-events: auto; z-index: 101; }
        #player-section.minimized .player-album-art { display: none; }
        #player-section.minimized .player-text { flex-grow: 1; }
        #player-section.minimized .player-title { font-size: 0.9rem; }
        #player-section.minimized .player-subtitle, #player-section.minimized .player-subtitle-small { display: none; }
        #player-section.minimized .player-toggle-button .toggle-icon { transform: rotate(180deg); }

        /* --- Status Messages, Loader, Hint Popup (Same) --- */
        .status-message { text-align: center; padding: 30px 20px; color: var(--text-secondary); font-size: 1rem; border-radius: 8px; background-color: var(--bg-secondary); margin-top: 20px; border: 1px dashed var(--border-color); display: none; }
        .status-message.visible { display: block; }
        .status-message .loader { margin-right: 10px; }
        .loader { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255, 255, 255, 0.2); border-radius: 50%; border-top-color: var(--accent-color); animation: spin 0.8s ease-in-out infinite; vertical-align: middle; }
        .btn-loader { width: 16px; height: 16px; border: 2px solid rgba(255, 255, 255, 0.3); border-top-color: var(--text-primary); }
        @keyframes spin { to { transform: rotate(360deg); } }
        #search-hint-popup { position: fixed; bottom: 20px; right: 20px; background-color: var(--hint-bg); color: var(--hint-text); padding: 10px 15px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); z-index: 101; display: none; align-items: center; gap: 10px; font-size: 0.85rem; opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease; }
        #search-hint-popup.visible { display: flex; opacity: 1; transform: translateY(0); }
        #close-hint-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.2rem; cursor: pointer; padding: 0 5px; line-height: 1; margin-left: 5px; }
        #close-hint-btn:hover { color: var(--text-primary); }


        /* --- Responsive Design --- */
        /* Desktop Base (covered above) */

        @media (max-width: 900px) { /* Medium screens / Tablets */
            .player-info, .player-extras { width: auto; flex-grow: 1; }
            .player-controls { width: auto; flex-grow: 2; max-width: 450px; }
            .player-extras { justify-content: center; }
            .search-area { min-width: 150px; }
            .header h1 { font-size: 1.6rem; }
        }

        @media (max-width: 768px) { /* Small tablets / Large phones */
            body { padding-bottom: calc(var(--player-height-mobile-med) + var(--toggle-button-height)); }
            .header { flex-direction: row; align-items: center; gap: 10px; }
            .header h1 { order: 1; flex-grow: 0; font-size: 1.5rem; }
            .main-view-toggle { order: 2; }
            .search-area { order: 3; flex-grow: 1; justify-content: flex-end; max-width: none; }
            .search-container.active { flex-grow: 1; max-width: none; }
            .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); }
            .file-name-list { font-size: 0.9rem; }
            .file-info-list { font-size: 0.75rem; min-width: 90px; }

            #player-section { height: var(--player-height-mobile-med); } /* Use CSS var */
            #player-section.minimized { height: 35px; }
            #player-section .player-content-wrapper { flex-direction: column; padding: 10px; gap: 10px; justify-content: space-between; }
            /* Row 1: Info */
            .player-info { justify-content: flex-start; text-align: left; width: 100%; order: 1; gap: 10px; }
            .player-album-art { width: 45px; height: 45px; }
            .player-title { font-size: 0.9rem; }
            .player-subtitle { font-size: 0.75rem; }
            .player-subtitle-small { font-size: 0.65rem; }
            /* Row 2: Progress */
            .player-controls .progress-container { order: 2; width: 100%; margin-top: 5px; }
            /* Row 3: Buttons */
            .player-controls .player-buttons { order: 3; width: 100%; justify-content: center; gap: 20px; margin-top: 8px; }
            .player-button { width: 38px; height: 38px; }
            .play-pause-btn { width: 48px; height: 48px; }
            /* Row 4: Extras */
            .player-extras { order: 4; width: 100%; justify-content: space-around; gap: 15px; padding-top: 5px; flex-wrap: nowrap; }
            .pitch-control { justify-content: center; min-width: fit-content; flex-grow: 1;}
            .volume-control { flex-grow: 1; justify-content: center; min-width: 130px; }
            .control-slider { width: 100px; }
            .reset-speed-button { margin-left: 8px; }

            .player-toggle-button { display: flex; }
        }

         @media (max-width: 480px) { /* Smaller phones */
             body { padding-bottom: calc(var(--player-height-mobile-small) + var(--toggle-button-height)); }
             .header { gap: 5px; padding: 10px 0; }
             .header h1 { font-size: 1.3rem; }
             .main-view-btn { font-size: 0.8rem; padding: 4px 8px;}
             .header-icon-button { width: 36px; height: 36px; font-size: 1.1rem; padding: 6px; }
             #search-box { padding-left: 35px; font-size: 0.85rem; }
             .search-icon-input { left: 12px; }
             .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
             .file-item-grid { padding: 10px; }
             .file-icon-grid { font-size: 2rem; margin-bottom: 8px; }
             .file-name-grid { font-size: 0.8rem; }
             .file-item-list { padding: 8px 10px; gap: 8px; }
             .file-icon-list { font-size: 1.1rem; width: 18px; }
             .file-name-list { font-size: 0.85rem; }
             .file-info-list { font-size: 0.7rem; min-width: 80px; gap: 5px; }
             .file-duration-list { width: 40px; }
             .file-size-list { min-width: 40px; }

             #player-section { height: var(--player-height-mobile-small); }
             #player-section.minimized { height: 35px; }
             #player-section .player-content-wrapper { gap: 8px; padding: 8px;}

             .player-album-art { width: 40px; height: 40px; }
             .player-title { font-size: 0.85rem; }
             .player-subtitle { font-size: 0.7rem; }
             .player-subtitle-small { font-size: 0.6rem; }

             .player-controls .player-buttons { gap: 15px; }
             .player-button { width: 34px; height: 34px; font-size: 1.0rem;}
             .play-pause-btn { width: 44px; height: 44px; }

             .player-extras { gap: 10px; flex-wrap: wrap; justify-content: center; }
             .pitch-control { width: 100%; justify-content: center; min-width: unset; }
             .volume-control { width: 100%; justify-content: center; min-width: unset; }
             .control-slider { width: 120px; }
             .reset-speed-button { order: 3; margin-left: 0; margin-top: 5px; }

             #search-hint-popup { bottom: 10px; right: 10px; font-size: 0.8rem; padding: 8px 12px; }
         }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header, Toggles, Search -->
        <div class="header">
            <h1>MP3 Archive</h1>
            <div class="main-view-toggle">
                <button id="folder-view-btn" class="main-view-btn" title="Browse by Folder">Folders</button>
                <button id="artist-view-btn" class="main-view-btn" title="Browse by Artist">Artists</button>
            </div>
            <div class="search-area">
                <button id="search-toggle-btn" class="header-icon-button" title="Search Files (/)">🔍</button>
                <div class="search-container" id="search-container">
                    <span class="search-icon-input">🔍</span>
                    <input type="search" id="search-box" placeholder="Search all files...">
                </div>
            </div>
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar">
            <div class="directory-container">
                <div class="directory-path" id="directory-path"></div>
            </div>
            <div class="view-toggle-buttons" id="grid-list-toggle-container">
                <button id="grid-view-btn" class="view-toggle-btn" title="Grid View">▦</button>
                <button id="list-view-btn" class="view-toggle-btn" title="List View">☰</button>
            </div>
        </div>

        <!-- Skeleton Loader -->
        <div id="skeleton-loader" class="file-browser-grid" style="display: none;">
            <!-- Placeholders -->
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
            <div class="file-item-grid skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        </div>

        <!-- File Browser -->
        <div id="file-browser-container"></div>

        <!-- Status Message -->
        <div id="status-message" class="status-message"></div>
    </div>

    <!-- Player Section -->
    <div id="player-section">
        <button id="player-toggle-btn" class="player-toggle-button" title="Minimize Player">
            <span class="toggle-icon">▼</span>
        </button>
        <div id="mini-progress-bar" class="mini-progress"></div>
        <div class="player-content-wrapper">
            <!-- Row 1: Info -->
            <div class="player-info">
                <div class="player-album-art" id="player-album-art">
                    <img id="album-art-img" src="" alt="Album Art" />
                    <span id="album-art-icon">🎵</span>
                    <div class="loader-overlay"><span class="loader"></span></div>
                </div>
                <div class="player-text">
                    <div id="now-playing" class="player-title" title="Not playing">Not playing</div>
                    <div id="now-playing-artist-album" class="player-subtitle" title="Select an MP3 file">Select an MP3 file</div>
                    <div id="now-playing-path" class="player-subtitle-small"></div>
                </div>
            </div>
            <!-- Rows 2 & 3: Controls (includes progress and buttons) -->
            <div class="player-controls">
                 <div class="progress-container">
                    <span id="current-time" class="progress-time">0:00</span>
                    <div class="progress-bar-wrapper" id="progress-wrapper">
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progress-bar"></div>
                        </div>
                    </div>
                    <span id="duration" class="progress-time">0:00</span>
                </div>
                 <div class="player-buttons">
                    <button class="player-button" id="prev-btn" disabled title="Previous Track (←)">⏮</button>
                    <button id="play-pause-btn" class="player-button play-pause-btn" disabled title="Play/Pause (Space)">▶</button>
                    <button class="player-button" id="next-btn" disabled title="Next Track (→)">⏭</button>
                    <button class="player-button" id="download-btn" title="Download current track" disabled>
                        <span class="btn-icon">💾</span>
                        <span class="loader btn-loader"></span>
                    </button>
                </div>
            </div>
             <!-- Row 4: Extras -->
            <div class="player-extras">
                 <div class="pitch-control">
                    <span class="control-label">Speed</span>
                    <input type="range" class="control-slider pitch-slider" id="pitch-slider" min="0.5" max="2" step="0.05" value="1" disabled>
                    <button id="reset-speed-btn" class="player-button reset-speed-button" title="Reset Speed to 1x">1×</button>
                </div>
                <div class="volume-control">
                    <span class="volume-icon" id="volume-icon">🔊</span>
                    <input type="range" class="control-slider volume-slider" id="volume-slider" min="0" max="1" step="0.05" value="0.7">
                </div>
            </div>
        </div><!-- End player-content-wrapper -->
    </div>

    <!-- Main Audio Element -->
    <audio id="audio-player" preload="metadata" style="display: none;"></audio>

    <!-- Search Hint Popup -->
    <div id="search-hint-popup">
         <span>Tip: Tap 🔍 or press <kbd>/</kbd> to search</span>
         <button id="close-hint-btn" title="Dismiss hint">✕</button>
    </div>

    <script>
        // --- Configuration ---
        const archiveIdentifier = 'mp3archive'; // <<< CHANGE THIS
        const archiveApiUrl = `https://archive.org/metadata/${archiveIdentifier}`;
        const archiveDownloadUrlBase = `https://archive.org/download/${archiveIdentifier}`;
        const excludedExtensions = ['.xml', '.txt', '.torrent', '.jpg', '.png', '.gif', '.log', '.php', '.html', '.css', '.js', '.pdf', '.zip', '.rar', '.jpeg', '.md5', '.json', '_meta.sqlite', '_files.xml'];
        const MAX_CACHE_SIZE = 20; // Cache for metadata/art fetching
        const SEEK_TIME_SECONDS = 5;
        const UNKNOWN_ARTIST = "[Unknown Artist]";
        const UNKNOWN_ALBUM = "[Unknown Album]";
        const TAG_FETCH_RANGE = 'bytes=0-131071'; // Fetch ~128KB for tags initially

        // --- DOM Elements ---
        const audioElement = document.getElementById('audio-player');
        const searchToggleBtn = document.getElementById('search-toggle-btn');
        const searchContainer = document.getElementById('search-container');
        const searchBox = document.getElementById('search-box');
        const directoryPathEl = document.getElementById('directory-path');
        const fileBrowserContainerEl = document.getElementById('file-browser-container');
        const skeletonLoaderEl = document.getElementById('skeleton-loader');
        const statusMessageEl = document.getElementById('status-message');
        const playerSection = document.getElementById('player-section');
        const playerToggleBtn = document.getElementById('player-toggle-btn');
        const playerContentWrapper = document.querySelector('.player-content-wrapper');
        const miniProgressBar = document.getElementById('mini-progress-bar');
        const playerAlbumArt = document.getElementById('player-album-art');
        const albumArtImg = document.getElementById('album-art-img');
        const albumArtIcon = document.getElementById('album-art-icon');
        const albumArtLoader = playerAlbumArt.querySelector('.loader-overlay');
        const nowPlayingEl = document.getElementById('now-playing');
        const nowPlayingArtistAlbumEl = document.getElementById('now-playing-artist-album');
        const nowPlayingPathEl = document.getElementById('now-playing-path');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const downloadBtn = document.getElementById('download-btn');
        const progressWrapper = document.getElementById('progress-wrapper');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeIcon = document.getElementById('volume-icon');
        const pitchSlider = document.getElementById('pitch-slider');
        const resetSpeedBtn = document.getElementById('reset-speed-btn'); // Added
        const searchHintPopup = document.getElementById('search-hint-popup');
        const closeHintBtn = document.getElementById('close-hint-btn');
        const gridViewBtn = document.getElementById('grid-view-btn');
        const listViewBtn = document.getElementById('list-view-btn');
        const gridListToggleContainer = document.getElementById('grid-list-toggle-container');
        const folderViewBtn = document.getElementById('folder-view-btn');
        const artistViewBtn = document.getElementById('artist-view-btn');

        // --- Audio State ---
        let isPlaying = false;
        let currentPlaybackRate = 1.0;
        let currentVolume = 0.7;

        // --- Data State ---
        let currentDirectory = '';
        let currentArtist = null;
        let currentAlbum = null;
        let allArchiveFiles = [];
        let artistsData = {};
        let isArtistsDataBuilt = false;
        let currentDirectoryItems = [];
        let currentTracklist = [];
        let currentTrackIndex = -1;
        let currentPlayingFile = null;
        let currentLayoutMode = localStorage.getItem('layoutMode') || 'grid';
        let currentMainView = localStorage.getItem('mainView') || 'folder';
        let isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true';

        // --- Caching (Metadata) ---
        const metadataCache = new Map();
        const cacheOrder = [];

        // --- Constants ---
        const VIEW_MODE_FOLDER = 'folder';
        const VIEW_MODE_ARTIST = 'artist';

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded");
            loadSettings();
            loadArchiveStructure(); // Start loading process
            setupEventListeners();
            updatePlayerUI(); // Set initial player state
            applyLayoutMode();
            applyMainViewMode();
            applyMinimizedState();
            updateBodyPadding();
            showSearchHintIfNeeded();
        });

        function loadSettings() {
             console.log("Loading settings...");
             currentVolume = parseFloat(localStorage.getItem('playerVolume') || '0.7');
             currentPlaybackRate = parseFloat(localStorage.getItem('playerRate') || '1.0');
             isPlayerMinimized = localStorage.getItem('playerMinimized') === 'true';
             currentLayoutMode = localStorage.getItem('layoutMode') || 'grid';
             currentMainView = localStorage.getItem('mainView') || 'folder';

             audioElement.volume = currentVolume;
             audioElement.playbackRate = currentPlaybackRate; // Set initial rate on audio element
             volumeSlider.value = currentVolume;
             pitchSlider.value = currentPlaybackRate;
             updateVolumeIcon(currentVolume);
             resetSpeedBtn.style.display = currentPlaybackRate === 1.0 ? 'none' : 'flex'; // Initial visibility based on loaded rate
             console.log("Settings loaded:", { currentVolume, currentPlaybackRate, isPlayerMinimized, currentLayoutMode, currentMainView });
        }

        function saveSetting(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                console.warn(`Could not save setting ${key}:`, e);
            }
        }

        // --- Archive.org API & Data Handling ---
        async function loadArchiveStructure() {
            console.log("loadArchiveStructure start");
            showInitialLoading(); // Show skeleton and status message

            try {
                const response = await fetch(archiveApiUrl);
                if (!response.ok) {
                    throw new Error(`Metadata fetch failed (Status: ${response.status} ${response.statusText || ''})`);
                }
                console.log("loadArchiveStructure metadata fetch OK");
                const data = await response.json();

                if (!data.files || !Array.isArray(data.files)) {
                    throw new Error('Invalid archive structure: No files array found.');
                }

                allArchiveFiles = processRawFiles(data.files);
                console.log(`Processed ${allArchiveFiles.length} total items from archive.`);
                const totalAudioFiles = allArchiveFiles.filter(f => f.isAudio).length;
                console.log(`Found ${totalAudioFiles} audio files in total.`);

                // Build artist data structure using the COMPLETE list
                buildArtistViewData(allArchiveFiles); // Pass the full list

                // Initial Render based on saved/default view
                console.log("loadArchiveStructure performing initial render based on view:", currentMainView);
                if (currentMainView === VIEW_MODE_ARTIST) {
                    renderArtistList();
                } else {
                    updateDirectoryView(''); // Render root folder
                }
                 updateMainViewToggleButtons();
                 hideInitialLoading();
                 console.log("loadArchiveStructure end");

            } catch (error) {
                console.error('Error loading archive:', error);
                // Ensure status is displayed on error
                displayStatus(`Error loading archive: ${error.message || 'Unknown error'}`, true);
                hideInitialLoading(); // Still hide skeleton even on error
            }
        }

        function processRawFiles(rawFiles) {
            console.log("processRawFiles start");
            const fileMap = new Map();
            rawFiles.forEach(file => fileMap.set(file.name, file));

            const processed = rawFiles.map(file => {
                const path = file.name;
                let displayName = path.split('/').filter(p => p).pop() || path;
                let isDirectory = path.endsWith('/');
                
                // Check if this is a directory by looking for child files
                if (!isDirectory && fileMap.size > 1) {
                    for (const otherPath of fileMap.keys()) {
                        if (otherPath !== path && otherPath.startsWith(path + '/')) {
                            isDirectory = true;
                            break;
                        }
                    }
                }

                let durationSeconds = undefined;
                if (file.length && !isNaN(parseFloat(file.length))) durationSeconds = parseFloat(file.length);
                
                // Extract metadata from file name if not available in API
                let apiArtist = file.creator || file.artist || null;
                let apiAlbum = file.album || null;
                let apiTitle = file.title || null;

                // Clean up metadata strings
                if (apiArtist && typeof apiArtist === 'string') {
                    apiArtist = apiArtist.split(';')[0].trim();
                }
                if (apiAlbum && typeof apiAlbum === 'string') {
                    apiAlbum = apiAlbum.split(';')[0].trim();
                }
                if (apiTitle && typeof apiTitle === 'string') {
                    apiTitle = apiTitle.split(';')[0].trim();
                }

                // Try to extract metadata from path if not available
                if (!apiArtist || !apiAlbum) {
                    const pathParts = path.split('/').filter(p => p);
                    if (pathParts.length >= 2) {
                        if (!apiArtist) apiArtist = pathParts[0];
                        if (!apiAlbum && pathParts.length > 1) apiAlbum = pathParts[1];
                    }
                }

                return {
                    name: file.name,
                    path: path,
                    size: file.size ? parseInt(file.size) : 0,
                    format: file.format || '',
                    isDirectory: isDirectory,
                    isAudio: !isDirectory && path.toLowerCase().endsWith('.mp3'),
                    displayName: displayName,
                    duration: durationSeconds,
                    artist: apiArtist,
                    album: apiAlbum,
                    title: apiTitle,
                    metadata: null
                };
            });

            // Filter out non-MP3 files and excluded extensions
            const filtered = processed.filter(file => {
                if (file.isDirectory) return true;
                if (file.isAudio) {
                    const extension = file.path.substring(file.path.lastIndexOf('.')).toLowerCase();
                    return !excludedExtensions.includes(extension);
                }
                return false;
            });

            // Sort directories first, then by name
            const sorted = filtered.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) return -1;
                if (!a.isDirectory && b.isDirectory) return 1;
                return (a.displayName || '').localeCompare(b.displayName || '');
            });

            console.log("processRawFiles end");
            return sorted;
        }

        function buildArtistViewData(files) {
            console.log(`Building artist view data from ${files.length} received items...`);
            const tempArtistsData = {};
            let audioFileCount = 0;

            files.forEach(file => {
                if (!file.isAudio) return;
                audioFileCount++;

                // Use metadata if available, otherwise fall back to file properties
                const artist = file.metadata?.artist || file.artist || UNKNOWN_ARTIST;
                const album = file.metadata?.album || file.album || UNKNOWN_ALBUM;
                const title = file.metadata?.title || file.title || file.displayName;

                if (!tempArtistsData[artist]) {
                    tempArtistsData[artist] = { _albums: {} };
                }
                if (!tempArtistsData[artist]._albums[album]) {
                    tempArtistsData[artist]._albums[album] = [];
                }

                // Update file with metadata if available
                const fileWithMetadata = {
                    ...file,
                    artist: artist,
                    album: album,
                    title: title
                };

                tempArtistsData[artist]._albums[album].push(fileWithMetadata);
            });

            // Sort tracks within each album
            Object.keys(tempArtistsData).forEach(artist => {
                Object.keys(tempArtistsData[artist]._albums).forEach(album => {
                    tempArtistsData[artist]._albums[album].sort((a, b) => {
                        // Try to sort by track number if available
                        if (a.metadata?.track && b.metadata?.track) {
                            return parseInt(a.metadata.track) - parseInt(b.metadata.track);
                        }
                        // Fall back to title sorting
                        return (a.title || a.displayName).localeCompare(b.title || b.displayName);
                    });
                });
            });

            // Sort artists alphabetically
            artistsData = Object.fromEntries(
                Object.entries(tempArtistsData).sort(([artistA], [artistB]) => 
                    artistA.localeCompare(artistB)
                )
            );

            isArtistsDataBuilt = true;
            console.log(`Artist view data built. Artists: ${Object.keys(artistsData).length}, Audio Files processed: ${audioFileCount}`);

            if (currentMainView === VIEW_MODE_ARTIST && !currentArtist && !currentAlbum && 
                statusMessageEl.textContent.includes("Building artist data")) {
                renderArtistList();
            }
        }

        // --- Skeleton Loader & Status ---
        function showInitialLoading() { console.log("Showing initial loading state"); showSkeletonLoader(true); statusMessageEl.innerHTML = `<span class="loader"></span>Loading archive...`; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; }
        function hideInitialLoading() { console.log("Hiding initial loading state"); hideSkeletonLoader(); if (statusMessageEl.textContent.includes("Loading archive")) { statusMessageEl.classList.remove('visible'); statusMessageEl.innerHTML = ''; } }
        function showSkeletonLoader(show) { skeletonLoaderEl.style.display = show ? (currentLayoutMode === 'grid' ? 'grid' : 'flex') : 'none'; skeletonLoaderEl.className = `file-browser-${currentLayoutMode} visible`; }
        function hideSkeletonLoader() { skeletonLoaderEl.style.display = 'none'; }
        function displayStatus(message, isError = false) { console.log("Displaying Status:", message, "Error:", isError); statusMessageEl.innerHTML = message; statusMessageEl.style.color = isError ? 'var(--accent-color)' : 'var(--text-secondary)'; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; hideSkeletonLoader(); /* Hide skeleton when showing explicit status */ }
        function hideLoading() { if (!statusMessageEl.style.color.includes('accent') && !statusMessageEl.textContent.includes("Building artist data")) { statusMessageEl.classList.remove('visible'); } } // Keep "Building..." message visible


        // --- View Mode Switching (Main & Layout) ---
        function setMainViewMode(mode) { if (mode === currentMainView) return; console.log("Setting main view to:", mode); currentMainView = mode; saveSetting('mainView', mode); applyMainViewMode(); currentArtist = null; currentAlbum = null; searchBox.value = ''; if(searchContainer.classList.contains('active')) toggleSearch(false); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; requestAnimationFrame(() => { if (mode === VIEW_MODE_ARTIST) { if (!isArtistsDataBuilt) { displayStatus("Building artist data..."); } else { renderArtistList(); } } else { updateDirectoryView(currentDirectory); } }); }
        function applyMainViewMode() { updateMainViewToggleButtons(); updateBreadcrumbs(); const showGridListToggle = (currentMainView === VIEW_MODE_FOLDER) || (currentMainView === VIEW_MODE_ARTIST && currentArtist && currentAlbum); gridListToggleContainer.style.display = showGridListToggle ? 'flex' : 'none'; console.log("Applied main view mode:", currentMainView); }
        function updateMainViewToggleButtons() { folderViewBtn.classList.toggle('active', currentMainView === VIEW_MODE_FOLDER); artistViewBtn.classList.toggle('active', currentMainView === VIEW_MODE_ARTIST); }
        function setLayoutMode(mode) { if (mode === currentLayoutMode) return; console.log("Setting layout mode to:", mode); currentLayoutMode = mode; saveSetting('layoutMode', mode); applyLayoutMode(); rerenderCurrentView(); }
        function applyLayoutMode() { gridViewBtn.classList.toggle('active', currentLayoutMode === 'grid'); listViewBtn.classList.toggle('active', currentLayoutMode === 'list'); skeletonLoaderEl.className = `file-browser-${currentLayoutMode} visible`; console.log("Applied layout mode:", currentLayoutMode);}

        // --- Re-rendering Logic ---
        function rerenderCurrentView() { console.log("Rerendering current view..."); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; requestAnimationFrame(() => { if (searchBox.value) { handleSearch(); } else if (currentMainView === VIEW_MODE_ARTIST) { if (currentArtist && currentAlbum) renderTrackListForArtist(currentArtist, currentAlbum); else if (currentArtist) renderAlbumList(currentArtist); else renderArtistList(); } else { updateDirectoryView(currentDirectory); } }); }

        // --- Rendering Functions (Folder View) ---
        function updateDirectoryView(path) { if (currentMainView !== VIEW_MODE_FOLDER) { console.warn("updateDirectoryView called while not in folder view"); return; } console.log("Updating folder view to path:", path); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentDirectory = path; currentArtist = null; currentAlbum = null; if (searchBox.value) { searchBox.value = ''; toggleSearch(false);} updateBreadcrumbs(); const items = getItemsInDirectory(allArchiveFiles, path); console.log(`Found ${items.length} items in directory '${path}'`); currentDirectoryItems = items; currentTracklist = items.filter(item => item.isAudio); currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; requestAnimationFrame(() => { renderFileBrowser(items); hideSkeletonLoader(); updatePlayerUI(); /* Update prev/next etc based on new list */ if (items.length === 0) displayStatus("This directory is empty.", false); else hideLoading(); }); }
        function getItemsInDirectory(allItems, dirPath) { console.log("getItemsInDirectory for:", dirPath); const items = new Map(); const dirPathLength = dirPath.length; allItems.forEach(item => { if (!item.path.startsWith(dirPath) || item.path === dirPath) return; const relativePath = item.path.substring(dirPathLength); const slashIndex = relativePath.indexOf('/'); if (slashIndex === -1) { if (!item.isDirectory) items.set(item.path, item); } else { const firstPart = relativePath.substring(0, slashIndex); const subDirPath = dirPath + firstPart + '/'; if (!items.has(subDirPath)) { let dirEntry = allItems.find(d => d.path === subDirPath && d.isDirectory); if (dirEntry) { items.set(subDirPath, dirEntry); } else { items.set(subDirPath, { name: subDirPath, path: subDirPath, displayName: firstPart, isDirectory: true, isAudio: false, size: 0, format: 'Directory (Synthesized)' }); } } if (item.isDirectory && item.path.endsWith('/') && slashIndex === (relativePath.length - 1)) { if (!items.has(item.path)) items.set(item.path, item); } } }); const result = Array.from(items.values()).sort((a, b) => { if (a.isDirectory && !b.isDirectory) return -1; if (!a.isDirectory && b.isDirectory) return 1; const nameA = a.displayName || ''; const nameB = b.displayName || ''; return nameA.localeCompare(nameB); }); console.log("getItemsInDirectory found items:", result.length); return result;}

        // --- Rendering Functions (Artist View) ---
        function renderArtistList() { if (currentMainView !== VIEW_MODE_ARTIST) return; console.log("Rendering artist list"); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = null; currentAlbum = null; updateBreadcrumbs(); if (!isArtistsDataBuilt) { displayStatus("Building artist data..."); return; } if (Object.keys(artistsData).length === 0) { displayStatus("No artist information found.", false); hideSkeletonLoader(); return; } const itemsToRender = Object.keys(artistsData).map(artistName => ({ name: artistName, isArtist: true, itemCount: Object.keys(artistsData[artistName]._albums).length })); currentDirectoryItems = itemsToRender; currentTracklist = []; currentTrackIndex = -1; updatePlayerUI(); requestAnimationFrame(() => { renderArtistAlbumBrowser(itemsToRender); hideSkeletonLoader(); hideLoading(); }); }
        function renderAlbumList(artistName) { if (currentMainView !== VIEW_MODE_ARTIST || !artistsData[artistName]) return; console.log("Rendering album list for:", artistName); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = artistName; currentAlbum = null; updateBreadcrumbs(); const albums = artistsData[artistName]._albums; if (Object.keys(albums).length === 0) { displayStatus(`No albums found for ${artistName}.`, false); hideSkeletonLoader(); return; } const itemsToRender = Object.keys(albums).map(albumName => ({ name: albumName, isAlbum: true, itemCount: albums[albumName].length })); currentDirectoryItems = itemsToRender; currentTracklist = []; currentTrackIndex = -1; updatePlayerUI(); requestAnimationFrame(() => { renderArtistAlbumBrowser(itemsToRender); hideSkeletonLoader(); hideLoading(); }); }
        function renderTrackListForArtist(artistName, albumName) { if (currentMainView !== VIEW_MODE_ARTIST || !artistsData[artistName]?._albums[albumName]) return; console.log(`Rendering track list for: ${artistName} - ${albumName}`); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; currentArtist = artistName; currentAlbum = albumName; updateBreadcrumbs(); const tracks = artistsData[artistName]._albums[albumName]; if (tracks.length === 0) { displayStatus(`No tracks found for ${albumName}.`, false); hideSkeletonLoader(); return; } currentDirectoryItems = tracks; currentTracklist = tracks; currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; updatePlayerUI(); requestAnimationFrame(() => { renderFileBrowser(tracks); hideSkeletonLoader(); hideLoading(); }); }

        // --- Combined Rendering Dispatchers ---
        function renderFileBrowser(items) { console.log("renderFileBrowser called with items:", items.length, "Layout:", currentLayoutMode); fileBrowserContainerEl.innerHTML = ''; fileBrowserContainerEl.className = ''; if (currentLayoutMode === 'list') { fileBrowserContainerEl.classList.add('file-browser-list'); renderFileBrowserList(items); } else { fileBrowserContainerEl.classList.add('file-browser-grid'); renderFileBrowserGrid(items); } }
        function renderArtistAlbumBrowser(items) { console.log("renderArtistAlbumBrowser called with items:", items.length, "Layout:", currentLayoutMode); fileBrowserContainerEl.innerHTML = ''; fileBrowserContainerEl.className = ''; if (currentLayoutMode === 'list') { fileBrowserContainerEl.classList.add('file-browser-list'); renderArtistAlbumList(items); } else { fileBrowserContainerEl.classList.add('file-browser-grid'); renderArtistAlbumGrid(items); } }

        // --- Grid/List Rendering Implementations ---
        function renderFileBrowserGrid(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-grid'; itemEl.dataset.path = item.path; const icon = document.createElement('div'); icon.className = 'file-icon-grid'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-grid'; nameEl.textContent = item.displayName || '[No Name]'; nameEl.title = item.displayName || item.path; const infoEl = document.createElement('div'); infoEl.className = 'file-info-grid'; if (item.isDirectory) { icon.textContent = '📁'; icon.classList.add('folder'); itemEl.addEventListener('click', () => updateDirectoryView(item.path)); infoEl.textContent = 'Folder'; } else if (item.isAudio) { icon.textContent = '🎵'; itemEl.addEventListener('click', () => playAudioFile(item, currentTracklist)); infoEl.textContent = formatFileSize(item.size); } itemEl.appendChild(icon); itemEl.appendChild(nameEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderArtistAlbumGrid(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-grid'; itemEl.dataset.name = item.name; const icon = document.createElement('div'); icon.className = 'file-icon-grid'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-grid'; nameEl.textContent = item.name; nameEl.title = item.name; const infoEl = document.createElement('div'); infoEl.className = 'file-info-grid'; if (item.isArtist) { icon.textContent = '👤'; icon.classList.add('artist'); itemEl.addEventListener('click', () => renderAlbumList(item.name)); infoEl.textContent = `${item.itemCount} Album${item.itemCount !== 1 ? 's' : ''}`; } else if (item.isAlbum) { icon.textContent = '💿'; icon.classList.add('album'); itemEl.addEventListener('click', () => renderTrackListForArtist(currentArtist, item.name)); infoEl.textContent = `${item.itemCount} Track${item.itemCount !== 1 ? 's' : ''}`; } itemEl.appendChild(icon); itemEl.appendChild(nameEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderFileBrowserList(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = `file-item-list ${item.isAudio || item.isDirectory ? '' : 'non-interactive'}`; itemEl.dataset.path = item.path; const icon = document.createElement('div'); icon.className = 'file-icon-list'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-list'; nameEl.textContent = item.title || item.displayName || '[No Name]'; nameEl.title = item.displayName || item.path; const infoEl = document.createElement('div'); infoEl.className = 'file-info-list'; const durationEl = document.createElement('span'); durationEl.className = 'file-duration-list'; const sizeEl = document.createElement('span'); sizeEl.className = 'file-size-list'; if (item.isDirectory) { icon.textContent = '📁'; icon.classList.add('folder'); itemEl.addEventListener('click', () => updateDirectoryView(item.path)); sizeEl.textContent = 'Folder'; } else if (item.isAudio) { icon.textContent = '🎵'; itemEl.addEventListener('click', () => playAudioFile(item, currentTracklist)); durationEl.textContent = item.duration ? formatTime(item.duration) : '--:--'; durationEl.dataset.path = item.path; sizeEl.textContent = formatFileSize(item.size); } else { icon.textContent = '📄'; sizeEl.textContent = formatFileSize(item.size); } itemEl.appendChild(icon); itemEl.appendChild(nameEl); infoEl.appendChild(durationEl); infoEl.appendChild(sizeEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }
        function renderArtistAlbumList(items) { items.forEach(item => { const itemEl = document.createElement('div'); itemEl.className = 'file-item-list'; itemEl.dataset.name = item.name; const icon = document.createElement('div'); icon.className = 'file-icon-list'; const nameEl = document.createElement('div'); nameEl.className = 'file-name-list'; nameEl.textContent = item.name; nameEl.title = item.name; const infoEl = document.createElement('div'); infoEl.className = 'file-info-list'; const countEl = document.createElement('span'); countEl.className = 'file-item-count'; if (item.isArtist) { icon.textContent = '👤'; icon.classList.add('artist'); itemEl.addEventListener('click', () => renderAlbumList(item.name)); countEl.textContent = `${item.itemCount} Album${item.itemCount !== 1 ? 's' : ''}`; } else if (item.isAlbum) { icon.textContent = '💿'; icon.classList.add('album'); itemEl.addEventListener('click', () => renderTrackListForArtist(currentArtist, item.name)); countEl.textContent = `${item.itemCount} Track${item.itemCount !== 1 ? 's' : ''}`; } itemEl.appendChild(icon); itemEl.appendChild(nameEl); infoEl.appendChild(countEl); itemEl.appendChild(infoEl); fileBrowserContainerEl.appendChild(itemEl); }); }

        function formatFileSize(bytes) { if (bytes === undefined || bytes === null || bytes < 0) return ''; if (bytes === 0) return '0 B'; if (bytes < 1024) return bytes + ' B'; const i = Math.floor(Math.log(bytes) / Math.log(1024)); const units = ['B', 'KB', 'MB', 'GB', 'TB']; const unitIndex = Math.min(i, units.length - 1); const fixedDigits = unitIndex >= 2 ? 1 : 0; return parseFloat((bytes / Math.pow(1024, unitIndex)).toFixed(fixedDigits)) + ' ' + units[unitIndex];}

        // --- Breadcrumbs ---
        function updateBreadcrumbs() { directoryPathEl.innerHTML = ''; if (currentMainView === VIEW_MODE_ARTIST) { const artistsCrumb = createArtistCrumb('Artists', null, null, !currentArtist && !currentAlbum); directoryPathEl.appendChild(artistsCrumb); if (currentArtist) { addSeparator(); const artistCrumb = createArtistCrumb(currentArtist, currentArtist, null, !currentAlbum); directoryPathEl.appendChild(artistCrumb); } if (currentAlbum) { addSeparator(); const albumCrumb = createArtistCrumb(currentAlbum, currentArtist, currentAlbum, true); directoryPathEl.appendChild(albumCrumb); } } else { const rootCrumb = createFolderCrumb('Root', '', currentDirectory === ''); directoryPathEl.appendChild(rootCrumb); const parts = currentDirectory.split('/').filter(part => part !== ''); let pathAccumulator = ''; parts.forEach((part) => { pathAccumulator += part + '/'; addSeparator(); const crumb = createFolderCrumb(part, pathAccumulator, pathAccumulator === currentDirectory); directoryPathEl.appendChild(crumb); }); } }
        function addSeparator() { const separator = document.createElement('span'); separator.className = 'directory-separator'; separator.textContent = '›'; directoryPathEl.appendChild(separator); }
        function createFolderCrumb(text, path, isCurrent) { const crumb = document.createElement('span'); crumb.className = `directory-crumb ${isCurrent ? 'current' : ''}`; crumb.textContent = text; if (!isCurrent) { crumb.addEventListener('click', () => updateDirectoryView(path)); } return crumb; }
        function createArtistCrumb(text, artist, album, isCurrent) { const crumb = document.createElement('span'); crumb.className = `directory-crumb ${isCurrent ? 'current' : ''}`; crumb.textContent = text; if (!isCurrent) { crumb.addEventListener('click', () => { if (artist && album) { renderAlbumList(artist); } else if (artist) { renderArtistList(); } else { renderArtistList(); } }); } return crumb; }

        // --- Search Functionality ---
        function toggleSearch(forceState) { const activate = forceState !== undefined ? forceState : !searchContainer.classList.contains('active'); if (activate) { searchContainer.classList.add('active'); searchBox.focus(); } else { searchContainer.classList.remove('active'); searchBox.blur(); } }
        function handleSearch() { console.log("Performing search..."); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; const searchTerm = searchBox.value.toLowerCase().trim(); if (!searchTerm) { applyMainViewMode(); rerenderCurrentView(); return; } const results = allArchiveFiles.filter(file => !file.isDirectory && file.isAudio && (file.path.toLowerCase().includes(searchTerm) || (file.title && file.title.toLowerCase().includes(searchTerm)) || (file.artist && file.artist.toLowerCase().includes(searchTerm)) || (file.album && file.album.toLowerCase().includes(searchTerm))) ).sort((a, b) => (a.title || a.displayName).localeCompare(b.title || b.displayName)); currentDirectoryItems = results; currentTracklist = results; currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1; updatePlayerUI(); /* Update prev/next */ directoryPathEl.innerHTML = ''; const searchCrumb = createFolderCrumb(`Search: "${searchTerm}"`, '', true); directoryPathEl.appendChild(searchCrumb); gridListToggleContainer.style.display = 'flex'; requestAnimationFrame(() => { renderFileBrowser(results); hideSkeletonLoader(); if (results.length === 0) displayStatus(`No results found for "${searchTerm}".`, false); else hideLoading(); }); }

        // --- Metadata Handling ---
        async function fetchTagsWithRange(url) {
            try {
                const response = await fetch(url, { headers: { 'Range': TAG_FETCH_RANGE } });
                if (!response.ok || !(response.status === 200 || response.status === 206)) {
                    throw new Error(`Tag fetch failed: ${response.status}`);
                }
                return await response.arrayBuffer();
            } catch (error) {
                console.warn(`Could not fetch initial bytes for tags (${url}):`, error);
                return null;
            }
        }

        async function getMetadataFromTags(file) {
            if (metadataCache.has(file.path)) {
                console.log("Metadata cache hit for:", file.path);
                return metadataCache.get(file.path);
            }

            console.log("Fetching tags for:", file.path);
            const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`;
            
            try {
                const tagData = await fetchTagsWithRange(fileUrl);
                if (!tagData) {
                    console.warn("No tag data received for:", file.path);
                    return {};
                }

                return new Promise((resolve) => {
                    if (typeof jsmediatags === 'undefined') {
                        console.warn("jsmediatags not loaded");
                        resolve({});
                        return;
                    }

                    jsmediatags.read(tagData, {
                        onSuccess: (tag) => {
                            // Extract and clean metadata
                            const metadata = {
                                title: tag.tags.title,
                                artist: tag.tags.artist,
                                album: tag.tags.album,
                                picture: tag.tags.picture,
                                year: tag.tags.year,
                                genre: tag.tags.genre,
                                track: tag.tags.track,
                                disk: tag.tags.disk
                            };

                            // Clean up metadata strings
                            if (metadata.artist && typeof metadata.artist === 'string') {
                                metadata.artist = metadata.artist.split(';')[0].trim();
                            }
                            if (metadata.album && typeof metadata.album === 'string') {
                                metadata.album = metadata.album.split(';')[0].trim();
                            }
                            if (metadata.title && typeof metadata.title === 'string') {
                                metadata.title = metadata.title.split(';')[0].trim();
                            }

                            // If no title in metadata, try to extract from filename
                            if (!metadata.title && file.displayName) {
                                metadata.title = file.displayName
                                    .replace(/\.[^/.]+$/, '') // Remove extension
                                    .split('/')
                                    .pop() // Get last part of path
                                    .replace(/_/g, ' ') // Replace underscores with spaces
                                    .replace(/\b\w/g, l => l.toUpperCase()); // Capitalize first letter of each word
                            }

                            manageMetadataCache(file.path, metadata);
                            resolve(metadata);
                        },
                        onError: (error) => {
                            console.warn('jsmediatags error:', file?.path, error.type);
                            resolve({});
                        }
                    });
                });
            } catch (error) {
                console.error("Error fetching metadata:", error);
                return {};
            }
        }

        function displayMetadataInPlayer(metadata) {
            // Get the best available title, artist, and album
            const title = metadata?.title || currentPlayingFile?.title || currentPlayingFile?.displayName || 'Unknown Title';
            const artist = metadata?.artist || currentPlayingFile?.artist || UNKNOWN_ARTIST;
            const album = metadata?.album || currentPlayingFile?.album || UNKNOWN_ALBUM;

            // Clean up the display name by removing file extension and path
            let cleanDisplayName = currentPlayingFile?.displayName || '';
            if (cleanDisplayName) {
                cleanDisplayName = cleanDisplayName.replace(/\.[^/.]+$/, ''); // Remove extension
                cleanDisplayName = cleanDisplayName.split('/').pop(); // Get last part of path
            }

            // Update the player display
            nowPlayingEl.textContent = title;
            nowPlayingEl.title = title;

            // Format artist and album text
            let artistAlbumText = '';
            if (artist === UNKNOWN_ARTIST && album === UNKNOWN_ALBUM) {
                artistAlbumText = cleanDisplayName || 'Unknown Artist / Album';
            } else if (artist === UNKNOWN_ARTIST) {
                artistAlbumText = album;
            } else if (album === UNKNOWN_ALBUM) {
                artistAlbumText = artist;
            } else {
                artistAlbumText = `${artist} • ${album}`;
            }
            nowPlayingArtistAlbumEl.textContent = artistAlbumText;
            nowPlayingArtistAlbumEl.title = artistAlbumText;

            // Show the path without the filename
            const pathParts = currentPlayingFile?.path?.split('/').filter(p => p);
            if (pathParts) {
                pathParts.pop(); // Remove the filename
                nowPlayingPathEl.textContent = pathParts.length > 0 ? pathParts.join('/') : '';
            } else {
                nowPlayingPathEl.textContent = '';
            }
            nowPlayingPathEl.title = currentPlayingFile?.path || '';

            // Handle album art
            albumArtLoader.classList.remove('visible');
            albumArtIcon.classList.remove('hidden');
            albumArtImg.classList.remove('loaded');
            albumArtImg.src = '';

            if (metadata?.picture) {
                try {
                    const { data, format } = metadata.picture;
                    let base64String = "";
                    for (let i = 0; i < data.length; i++) {
                        base64String += String.fromCharCode(data[i]);
                    }
                    const imageUrl = `data:${format};base64,${window.btoa(base64String)}`;
                    
                    // Add loading state
                    albumArtLoader.classList.add('visible');
                    albumArtIcon.classList.add('hidden');
                    
                    // Handle image loading
                    albumArtImg.onload = () => {
                        albumArtImg.classList.add('loaded');
                        albumArtLoader.classList.remove('visible');
                        albumArtIcon.classList.add('hidden');
                    };
                    
                    // Handle image errors
                    albumArtImg.onerror = () => {
                        albumArtImg.classList.remove('loaded');
                        albumArtLoader.classList.remove('visible');
                        albumArtIcon.classList.remove('hidden');
                    };
                    
                    albumArtImg.src = imageUrl;
                } catch (e) {
                    console.error("Error displaying album art:", e);
                    albumArtIcon.classList.remove('hidden');
                }
            }
        }

        // --- Caching Logic (Metadata) ---
        function manageMetadataCache(filePath, data) {
            if (metadataCache.size >= MAX_CACHE_SIZE) {
                const oldestPath = cacheOrder.shift();
                if (oldestPath) {
                    metadataCache.delete(oldestPath);
                }
            }
            metadataCache.set(filePath, data);
            cacheOrder.push(filePath);
        }

        function clearMetadataCache() {
            metadataCache.clear();
            cacheOrder.length = 0;
            console.log("Metadata cache cleared.");
        }

        // --- Audio Playback (Using <audio> Element) ---
        function playAudioFile(file, contextTracklist) {
            if (!file || !file.isAudio) return;
            console.log("Requesting playback:", file.path);
            stopPlayback();
            currentPlayingFile = file;
            currentTracklist = contextTracklist || [];
            currentTrackIndex = currentTracklist.findIndex(track => track.path === file.path);
            updatePlayerUI(true, 'Loading...');
            displayMetadataInPlayer({ title: file.title || file.displayName, artist: file.artist, album: file.album });
            
            const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`;
            audioElement.src = fileUrl;
            audioElement.load();
            
            audioElement.play().catch(error => {
                console.warn("Playback initiation failed:", error.message);
                updatePlayerUI();
                playPauseBtn.textContent = '▶';
            });

            getMetadataFromTags(file).then(tagsMetadata => {
                if (currentPlayingFile && currentPlayingFile.path === file.path) {
                    currentPlayingFile.metadata = tagsMetadata;
                    currentPlayingFile.title = tagsMetadata?.title || currentPlayingFile.title;
                    currentPlayingFile.artist = tagsMetadata?.artist || currentPlayingFile.artist;
                    currentPlayingFile.album = tagsMetadata?.album || currentPlayingFile.album;
                    displayMetadataInPlayer(tagsMetadata);
                }
            });
        }

        function stopPlayback(clearInfo = false) {
            console.log("Stopping playback. Clear info:", clearInfo);
            audioElement.pause();
            audioElement.removeAttribute('src');
            audioElement.load();
            isPlaying = false;
            if (clearInfo) {
                currentPlayingFile = null;
                currentTrackIndex = -1;
                updatePlayerUI();
            } else {
                updatePlayerUI();
                updateProgress();
            }
        }

        function togglePlayback() {
            if (!currentPlayingFile) return;
            if (audioElement.paused) {
                audioElement.play().catch(e => console.error("Play failed:", e));
            } else {
                audioElement.pause();
            }
        }

        function seek(offsetSeconds) {
            if (!currentPlayingFile || isNaN(audioElement.duration)) return;
            const currentTime = audioElement.currentTime;
            let seekTime = currentTime + offsetSeconds;
            seekTime = Math.max(0, Math.min(seekTime, audioElement.duration));
            console.log(`Seeking by ${offsetSeconds}s to: ${formatTime(seekTime)}`);
            audioElement.currentTime = seekTime;
            updateProgress();
        }

        function playNext() {
            if (currentTracklist.length === 0 || currentTrackIndex === -1) {
                console.log("PlayNext: No tracklist/index");
                return;
            }
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= currentTracklist.length) nextIndex = 0;
            if (currentTracklist[nextIndex]) {
                playAudioFile(currentTracklist[nextIndex], currentTracklist);
            } else {
                console.log("PlayNext: Couldn't find next track, stopping.");
                stopPlayback(true);
            }
        }

        function playPrev() {
            if (currentTracklist.length === 0 || currentTrackIndex === -1) {
                console.log("PlayPrev: No tracklist/index");
                return;
            }
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) prevIndex = currentTracklist.length - 1;
            if (currentTracklist[prevIndex]) {
                playAudioFile(currentTracklist[prevIndex], currentTracklist);
            } else {
                console.log("PlayPrev: Couldn't find prev track, stopping.");
                stopPlayback(true);
            }
        }

        async function triggerDownload() {
            if (!currentPlayingFile || !currentPlayingFile.path || downloadBtn.classList.contains('loading') || downloadBtn.disabled) return;
            
            const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(currentPlayingFile.path)}`;
            const filename = currentPlayingFile.displayName || currentPlayingFile.path.split('/').pop();
            console.log(`Initiating download for: ${filename}`);
            
            downloadBtn.classList.add('loading');
            downloadBtn.disabled = true;
            
            try {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
                console.log(`Download triggered for ${filename}`);
            } catch (error) {
                console.error("Download failed:", error);
                alert(`Failed to download "${filename}". Error: ${error.message}`);
            } finally {
                downloadBtn.classList.remove('loading');
                downloadBtn.disabled = !currentPlayingFile;
            }
        }


        // --- UI Updates ---
        function updatePlayerUI(isLoading = false, loadingMessage = 'Loading...') { const hasActiveTrack = !!currentPlayingFile; const durationKnown = hasActiveTrack && !isNaN(audioElement.duration) && audioElement.duration > 0; const canSeek = hasActiveTrack && durationKnown && !isLoading; playPauseBtn.disabled = !hasActiveTrack || isLoading; pitchSlider.disabled = !hasActiveTrack || isLoading; resetSpeedBtn.disabled = !hasActiveTrack || isLoading; downloadBtn.disabled = !hasActiveTrack || isLoading || downloadBtn.classList.contains('loading'); volumeSlider.disabled = false; prevBtn.disabled = !(currentTracklist && currentTracklist.length > 1 && currentTrackIndex !== -1); nextBtn.disabled = !(currentTracklist && currentTracklist.length > 1 && currentTrackIndex !== -1); progressWrapper.style.cursor = canSeek ? 'pointer' : 'default'; if (isLoading) { albumArtLoader.classList.add('visible'); albumArtIcon.classList.add('hidden'); albumArtImg.classList.remove('loaded'); albumArtImg.src = ''; playPauseBtn.textContent = '⏳'; durationEl.textContent = '--:--'; currentTimeEl.textContent = '--:--'; progressBar.style.width = '0%'; miniProgressBar.style.setProperty('--progress-width', '0%'); } else if (hasActiveTrack) { if (!currentPlayingFile.metadata) { displayMetadataInPlayer({}); } albumArtLoader.classList.remove('visible'); playPauseBtn.textContent = audioElement.paused ? '▶' : '⏸'; if (durationKnown) durationEl.textContent = formatTime(audioElement.duration); else durationEl.textContent = '--:--'; updateProgress(); } else { albumArtLoader.classList.remove('visible'); albumArtImg.classList.remove('loaded'); albumArtImg.src = ''; albumArtIcon.classList.remove('hidden'); nowPlayingEl.textContent = 'Not playing'; nowPlayingEl.title = 'Not playing'; nowPlayingArtistAlbumEl.textContent = 'Select an MP3 file'; nowPlayingArtistAlbumEl.title = 'Select an MP3 file'; nowPlayingPathEl.textContent = ''; playPauseBtn.textContent = '▶'; playPauseBtn.disabled = true; pitchSlider.disabled = true; resetSpeedBtn.disabled = true; resetSpeedBtn.style.display = 'none'; downloadBtn.disabled = true; prevBtn.disabled = true; nextBtn.disabled = true; durationEl.textContent = '0:00'; currentTimeEl.textContent = '0:00'; progressBar.style.width = '0%'; miniProgressBar.style.setProperty('--progress-width', '0%'); } }
        function updateProgress() { const currentTime = audioElement.currentTime || 0; const duration = audioElement.duration || 0; currentTimeEl.textContent = formatTime(currentTime); const progressPercent = (duration > 0 && !isNaN(duration)) ? (currentTime / duration) * 100 : 0; const progressWidth = `${Math.min(100, progressPercent)}%`; progressBar.style.width = progressWidth; if (miniProgressBar.style.getPropertyValue('--progress-width') !== progressWidth) miniProgressBar.style.setProperty('--progress-width', progressWidth); }
        function updateFileDurationInList(filePath, durationSeconds) { if (currentLayoutMode !== 'list' || !durationSeconds || isNaN(durationSeconds)) return; const durationStr = formatTime(durationSeconds); const durationElement = fileBrowserContainerEl.querySelector(`.file-duration-list[data-path="${CSS.escape(filePath)}"]`); if (durationElement && durationElement.textContent !== durationStr) durationElement.textContent = durationStr; }
        function updateVolumeIcon(volume) { volumeIcon.textContent = (volume <= 0) ? '🔇' : (volume < 0.5) ? '🔈' : '🔊'; }

        // --- Minimizable Player & Body Padding ---
        function togglePlayerMinimized() { isPlayerMinimized = !isPlayerMinimized; applyMinimizedState(); saveSetting('playerMinimized', isPlayerMinimized); updateBodyPadding(); }
        function applyMinimizedState() { const toggleIcon = playerToggleBtn.querySelector('.toggle-icon'); if (isPlayerMinimized) { playerSection.classList.add('minimized'); if(toggleIcon) toggleIcon.textContent = '▲'; playerToggleBtn.title = "Expand Player"; } else { playerSection.classList.remove('minimized'); if(toggleIcon) toggleIcon.textContent = '▼'; playerToggleBtn.title = "Minimize Player"; } }
        function updateBodyPadding() { let playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-desktop').replace('px', '')); let toggleHeight = 0; if (window.matchMedia("(max-width: 768px)").matches) { playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-mobile-med').replace('px', '')); toggleHeight = parseInt(getComputedStyle(playerSection).getPropertyValue('--toggle-button-height').replace('px', '')); } if (window.matchMedia("(max-width: 480px)").matches) { playerHeight = isPlayerMinimized ? 35 : parseInt(getComputedStyle(playerSection).getPropertyValue('--player-height-mobile-small').replace('px', '')); toggleHeight = parseInt(getComputedStyle(playerSection).getPropertyValue('--toggle-button-height').replace('px', '')); } const totalPadding = playerHeight + (toggleHeight > 0 && !isPlayerMinimized ? toggleHeight : 0) + 20; document.body.style.paddingBottom = `${totalPadding}px`; }

        // --- Helper Functions ---
        function formatTime(seconds) { if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '0:00'; const totalSeconds = Math.floor(seconds); const mins = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }
        function showSearchHintIfNeeded() { if (localStorage.getItem('searchHintDismissed') !== 'true') { setTimeout(() => searchHintPopup?.classList.add('visible'), 500); } }
        function dismissSearchHint() { if (!searchHintPopup) return; searchHintPopup.style.opacity = '0'; setTimeout(() => searchHintPopup.classList.remove('visible'), 300); try { localStorage.setItem('searchHintDismissed', 'true'); } catch (e) { console.warn("Could not save hint dismissal state:", e); } }

        // --- Event Listeners ---
        function setupEventListeners() {
            console.log("Setting up event listeners");
            
            // Search
            searchToggleBtn.addEventListener('click', () => toggleSearch());
            searchBox.addEventListener('input', handleSearch);
            searchBox.addEventListener('search', () => { if (!searchBox.value) handleSearch(); });

            // Keyboard Shortcuts
            document.addEventListener('keydown', (e) => {
                const activeEl = document.activeElement;
                const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
                
                if (e.key === '/' && !isInputFocused) {
                    e.preventDefault();
                    toggleSearch(true);
                }
                else if (e.key === 'Escape' && searchContainer.classList.contains('active')) {
                    toggleSearch(false);
                    if (searchBox.value) {
                        searchBox.value = '';
                        handleSearch();
                    }
                }
                else if (e.code === 'Space' && !isInputFocused) {
                    e.preventDefault();
                    if (!playPauseBtn.disabled) togglePlayback();
                }
                else if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isInputFocused && currentPlayingFile && !isNaN(audioElement.duration)) {
                    e.preventDefault();
                    const seekDirection = e.key === 'ArrowLeft' ? -1 : 1;
                    seek(seekDirection * SEEK_TIME_SECONDS);
                }
            });

            // Player Controls
            playPauseBtn.addEventListener('click', togglePlayback);
            prevBtn.addEventListener('click', playPrev);
            nextBtn.addEventListener('click', playNext);
            downloadBtn.addEventListener('click', triggerDownload);
            playerToggleBtn.addEventListener('click', togglePlayerMinimized);
            
            progressWrapper.addEventListener('click', (e) => {
                if (!currentPlayingFile || isNaN(audioElement.duration)) return;
                const rect = progressWrapper.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const progressRatio = Math.max(0, Math.min(1, clickX / rect.width));
                const seekTime = progressRatio * audioElement.duration;
                console.log(`Seek click to: ${formatTime(seekTime)}`);
                audioElement.currentTime = seekTime;
                updateProgress();
            });
            
            volumeSlider.addEventListener('input', () => {
                currentVolume = parseFloat(volumeSlider.value);
                audioElement.volume = currentVolume;
                updateVolumeIcon(currentVolume);
                saveSetting('playerVolume', currentVolume);
            });
            
            pitchSlider.addEventListener('input', () => {
                const newRate = parseFloat(pitchSlider.value);
                currentPlaybackRate = newRate;
                audioElement.playbackRate = newRate;
                saveSetting('playerRate', currentPlaybackRate);
                resetSpeedBtn.style.display = newRate === 1.0 ? 'none' : 'flex';
            });
            
            resetSpeedBtn.addEventListener('click', () => {
                currentPlaybackRate = 1.0;
                audioElement.playbackRate = 1.0;
                pitchSlider.value = 1.0;
                saveSetting('playerRate', 1.0);
                resetSpeedBtn.style.display = 'none';
            });

            // Audio Element Event Listeners
            audioElement.addEventListener('play', () => {
                console.log("Audio Event: play");
                isPlaying = true;
                updatePlayerUI();
            });
            
            audioElement.addEventListener('pause', () => {
                console.log("Audio Event: pause");
                isPlaying = false;
                updatePlayerUI();
            });
            
            audioElement.addEventListener('ended', () => {
                console.log("Audio Event: ended");
                playNext();
            });
            
            audioElement.addEventListener('timeupdate', updateProgress);
            
            audioElement.addEventListener('loadedmetadata', () => {
                console.log("Audio Event: loadedmetadata. Duration:", audioElement.duration);
                if (currentPlayingFile) {
                    updateFileDurationInList(currentPlayingFile.path, audioElement.duration);
                }
                updatePlayerUI();
            });
            
            audioElement.addEventListener('error', (e) => {
                console.error('Audio Element Error:', audioElement.error?.code, audioElement.error?.message, e);
                if(currentPlayingFile) {
                    displayStatus(`Error playing ${currentPlayingFile.displayName}: ${audioElement.error?.message || 'Unknown playback error'}`, true);
                    stopPlayback(true);
                } else {
                    displayStatus(`Playback Error: ${audioElement.error?.message || 'Unknown playback error'}`, true);
                }
            });
            
            audioElement.addEventListener('waiting', () => {
                console.log("Audio Event: waiting (buffering)");
                updatePlayerUI(true, 'Buffering...');
            });
            
            audioElement.addEventListener('canplay', () => {
                console.log("Audio Event: canplay");
                if(isPlaying) updatePlayerUI();
            });
            
            audioElement.addEventListener('ratechange', () => {
                console.log("Audio Event: ratechange");
                currentPlaybackRate = audioElement.playbackRate;
                pitchSlider.value = currentPlaybackRate;
                resetSpeedBtn.style.display = currentPlaybackRate === 1.0 ? 'none' : 'flex';
                saveSetting('playerRate', currentPlaybackRate);
            });

            // View Mode Toggles
            folderViewBtn.addEventListener('click', () => setMainViewMode(VIEW_MODE_FOLDER));
            artistViewBtn.addEventListener('click', () => setMainViewMode(VIEW_MODE_ARTIST));
            gridViewBtn.addEventListener('click', () => setLayoutMode('grid'));
            listViewBtn.addEventListener('click', () => setLayoutMode('list'));

            // Search Hint
            closeHintBtn.addEventListener('click', dismissSearchHint);

            // Update body padding on resize
            window.addEventListener('resize', updateBodyPadding);
            
            console.log("Event listeners setup complete");
        }

    </script>
</body>
</html>
